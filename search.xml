<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2018%2F05%2F10%2FDynamic-Programming%2F</url>
    <content type="text"><![CDATA[In computer science, mathematics, management science, economics and bioinformatics, dynamic programming (also known as dynamic optimization) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.1 Big Businessinput: 2 arrays a and b, where a represents the royalties of the film and b represents the money that the movie can sell. Principal k.output: return maximum profit can be made by principal (k). å…¸åž‹çš„ DP, æ±‚æœ€å¤§åˆ©æ¶¦. ä¸»è¦æ–¹å‘æœ‰2ç‚¹, å¦‚æžœå”®ä»·æ¯”ç‰ˆæƒè´¹è¦é«˜, æ‰æœ‰åˆ©æ¶¦, å¦åˆ™æ€Žä¹ˆå–éƒ½æ˜¯èµ”é’±çš„. é€šè¿‡ä¹°å–, æœ¬é‡‘å¯èƒ½ä¼šå¢žé•¿, ä»Žè€Œå¯ä»¥è´­ä¹°æ›´è´µçš„ç”µå½±. æ•°ç»„ a ä¸Ž b çš„å…³ç³»æ˜¯ä¸€ä¸€å¯¹åº”çš„, é‚£ä¹ˆè‚¯å®šå°±ä¸èƒ½å¯¹æ•°ç»„è¿›è¡ŒæŽ’åºäº†. ç¬¬ä¸€ä¸ªæƒ³æ³•æ˜¯, é€šè¿‡ä¸æ–­å¾ªçŽ¯çš„æ–¹å¼æŽ’æŸ¥æ‰€æœ‰ç›ˆåˆ©çš„å½±ç‰‡. å› ä¸ºéœ€è¦åˆ¤æ–­å½“å‰æœ¬é‡‘é¢åº¦æ˜¯å¦å¯ä»¥è´­ä¹°å½±ç‰‡, æ‰€ä»¥è¦ä¿ç•™ç‰ˆæƒè´¹ä¸Žåˆ©æ¶¦ä¹‹é—´ä¸€ä¸€å¯¹åº”çš„å…³ç³». å¯ä»¥ä½¿ç”¨ä¸€ä¸ª Map&lt;a[i], b[i] - a[i&gt;], åŒæ—¶åœ¨ map ä¸ä¸ºç©º, ä¸”åˆ©æ¶¦ä¸ä¸ºé›¶çš„æƒ…å†µä¸‹,ä¸åœçš„è¿›è¡Œå¾ªçŽ¯æŸ¥æ‰¾. åœ¨å®Œå…¨å€’åºçš„çš„æƒ…å†µä¸‹, æ—¶é—´å¤æ‚åº¦ä¼šå˜æˆ O(n^2). å¦‚æžœå¯ä»¥å¯¹ç‰ˆæƒè´¹ç”¨è¿›è¡ŒæŽ’åº, é‚£ä¹ˆå°±å¯ä»¥é€šè¿‡ä¸€æ¬¡å¾ªçŽ¯æ‰¾å‡ºæ‰€æœ‰å¯èƒ½è´­ä¹°çš„å½±ç‰‡. æ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogn + O(n)), æ‰€ä»¥è¿˜æ˜¯ O(nlogn). 12345678910111213141516171819202122232425public class BigBusiness &#123; /** * @param a: The cost of the film * @param b: The price of the selling of the film * @param k: The principal * @return: The answer */ public int bigBusiness(int[] a, int[] b, int k) &#123; if (a == null || b == null) &#123; return -1; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; a.length; i++)&#123; list.add(b[i] - a[i]); &#125; for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i) &gt; 0 &amp;&amp; a[i] &lt;= k) &#123; k += list.get(i); &#125; &#125; return k; &#125;&#125; 1.Wiki â†©]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure VII Heap&PriorityQueue]]></title>
    <url>%2F2018%2F05%2F08%2FData-Structure-VII-Heap-PriorityQueue%2F</url>
    <content type="text"><![CDATA[Heap is a tree-like data structure. Every node must satisfy the heap property (max/min/etc). In java, heap is implemented as PriorityQueue&lt;&gt;(size, Comparator). Due to this property, the time complexity of insertion and deletion are both O(logn). Implement a Heap Using ArrayConstructor takes different parameters, with default capacity and heapify input array. Implements basic operations, offer, poll, peek, size, and isEmpty. With resize function, the priority queue can expand its capacity when itâ€™s half full. The amortized time complexity for offer and poll remain constant.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class MyPQ &#123; private int size; private int SCALE = 2; private int INITIAL_CAP = 15; private int[] array; public MyPQ()&#123; array = new int[INITIAL_CAP]; size = 0; &#125; public MyPQ(int[] array) &#123; this.array = array; size = array.length; heapify(); &#125; public void offer(int e) &#123; if (size == array.length / 2) &#123; resize(); &#125; if (size == 0) &#123; array[0] = e; &#125; else &#123; array[size] = e; &#125; size++; percolateUp(); &#125; public Integer poll()&#123; if (size == 0) &#123; return null; &#125; int peek = array[0]; array[0] = array[size - 1]; size--; percolateDown(0); return peek; &#125; public Integer peek() &#123; if (size == 0) &#123; return null; &#125; return array[0]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; private void percolateUp() &#123; int index = size - 1; while (index &gt;= 0) &#123; int parent = (index - 1) / 2; if (array[index] &lt; array[parent]) &#123; swap(array, index, parent); &#125; else &#123; break; &#125; index = parent; &#125; &#125; private void percolateDown(int index) &#123; while (index &lt;= (size - 2) / 2) &#123; int left = index * 2 + 1; int right = index * 2 + 2; int smallest = left; if (array[right] &lt; array[left]) &#123; smallest = right; &#125; if (array[index] &lt; array[smallest]) &#123; break; &#125; else &#123; swap(array, smallest, index); &#125; index = smallest; &#125; &#125; private void heapify() &#123; for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; percolateDown(i); &#125; &#125; private void resize() &#123; int[] newArr = new int[array.length * SCALE]; for (int i = 0; i &lt; array.length; i++) &#123; newArr[i] = array[i]; &#125; array = newArr; &#125; private void swap(int[] arr, int one, int two) &#123; int temp = arr[one]; arr[one] = arr[two]; arr[two] = temp; &#125;&#125;public class MyPQTest &#123; private MyPQ pq = new MyPQ(); private MyPQ pq2 = new MyPQ(new int[]&#123;3, 5, 7, 0, 1, 2, -10&#125;); @Test public void offer() &#123; pq.offer(5); pq.offer(-1); pq.offer(0); pq.offer(9); assertEquals(-1, (Object)pq.peek()); assertEquals(-1, (Object)pq.poll()); assertEquals(3, pq.size()); assertEquals(false, pq.isEmpty()); assertEquals(0, (Object)pq.peek()); assertEquals(0, (Object)pq.poll()); assertEquals(2, pq.size()); assertEquals(5, (Object)pq.poll()); assertEquals(1, pq.size()); assertEquals(9, (Object)pq.poll()); assertEquals(null, pq.poll()); assertEquals(true, pq.isEmpty()); assertEquals(-10, (Object)pq2.peek()); &#125;&#125; Heapifyinput: an int array.output: none. A min heap must satisfy following property, for a list of n elements {k1, k2â€¦ kiâ€¦kn}, (ki &lt;= k2i, ki &lt;= k2i+1)æˆ–è€…(ki &gt;= k2i, ki &gt;= k2i+1), (i = 1, 2, 3, 4â€¦ n/2).In other words, left child (node * 2 + 1) right child (node * 2 + 2)must not greater than node. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Heapify &#123; /** * @param A: Given an integer array * @return: nothing */ public void heapify(int[] A) &#123; // write your code here if (A == null || A.length &lt;= 1) &#123; return; &#125; for (int i = A.length / 2; i &gt;= 0; i--) &#123; shiftDown(A, i); &#125; &#125; private void shiftDown(int[] arr, int curr) &#123; int length = arr.length; while (curr &lt; length) &#123; int smallestIndex = curr; int leftChild = curr * 2 + 1; int rightChild = curr * 2 + 2; if (leftChild &lt; length &amp;&amp; arr[leftChild] &lt;= arr[smallestIndex]) &#123; smallestIndex = leftChild; &#125; if (rightChild &lt; length &amp;&amp; arr[rightChild] &lt;= arr[smallestIndex]) &#123; smallestIndex = rightChild; &#125; //whether curr is smaller than its children or curr is leaf; if (smallestIndex == curr) &#123; break; &#125; swap(arr, smallestIndex, curr); //from current node down curr = smallestIndex; &#125; &#125; private void swap(int[] arr, int one, int two) &#123; int temp = arr[one]; arr[one] = arr[two]; arr[two] = temp; &#125;&#125; Merge K Sorted Listsinput: lists of sorted linked list.output: one sorted linked list. The most intuitive way of solving this problems is that merge lists two by two. Since there are soreted linked list, recursively call a helper function and merge. Problem is that every node is visited more than one time.Another approach is using heap. Only keep the reference of head of the linked list. It taks O(k) to build min heap. Offer and poll operation take O(lok). There a k lists and every list has n nodes. The time complexity is O(knlogk). Space complexity is O(k) for list nodes in the priority queue. 12345678910111213141516171819202122232425262728293031323334public class MergeKLists &#123; /** * @param lists: a list of ListNode * @return: The head of one sorted list. */ public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists == null || lists.size() == 0) &#123; return null; &#125; ListNode dummy = new ListNode(-1); ListNode newHead = dummy; PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(lists.size(), new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode o1, ListNode o2) &#123; return o1.val &lt; o2.val ? -1 : (o1.val == o2.val ? 0 : 1); &#125; &#125;); for (ListNode node : lists) &#123; if (node != null) pq.offer(node); &#125; while (!pq.isEmpty()) &#123; ListNode cur = pq.poll(); newHead.next = cur; newHead = newHead.next; if (cur.next != null) &#123; pq.offer(cur.next); &#125; cur.next = null; &#125; return dummy.next; &#125; Merge K sorted arraysinput: list of sorted arrays.output: one sorted array. Similar to merge linked list. Only difference is that element in the array doesnâ€™t have reference to its neightbor. Creating a cell class with all information about an elementâ€™s neighbor. Using priority queue to store first element of each row because the rows in the 2D array may not have the same number of column. The time complexity is O(Nlogk) where N is the totol number of input and k is the number of arrays. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647ublic class MergeKArrays &#123; class Cell &#123; int val, row, col; public Cell(int val, int row, int col) &#123; this.val = val; this.row = row; this.col = col; &#125; &#125; /** * @param arrays * @return */ public int[] mergekSortedArrays(int[][] arrays) &#123; if (arrays == null || arrays[0] == null || arrays.length == 0 || arrays[0].length == 0) &#123; return new int[]&#123;&#125;; &#125; PriorityQueue&lt;Cell&gt; pq = new PriorityQueue&lt;&gt;(arrays.length, new Comparator&lt;Cell&gt;() &#123; @Override public int compare(Cell o1, Cell o2) &#123; return o1.val &lt; o2.val ? -1 : o1.val == o2.val ? 0 : 1; &#125; &#125;); //O(array.length) int length = 0; for (int i = 0; i &lt; arrays.length; i++) &#123; pq.offer(new Cell(arrays[i][0], i, 0)); length += arrays[i].length; &#125; int index = 0; int[] result = new int[length]; while (!pq.isEmpty()) &#123; Cell cur = pq.poll(); result[index++] = cur.val; if (cur.col + 1 &lt; arrays[cur.row].length) &#123; pq.offer(new Cell(arrays[cur.row][cur.col + 1], cur.row, cur.col + 1)); &#125; &#125; return result; &#125;&#125; High Fiveinput: list of Records with id and score.output: return the average of top 5 score for each id. Extra data structure needs to be used here to record scores for each id, and the average of score for the id. Using two maps, for list of scores, and another one for final result.It asks top 5 score. Intuitively, top number of something fits the property of max heap. Using priority queue to record scores, calculate averate of top 5 numbers. Time compexity is O(n) for store all data from the input. O(knlogn) for poping k times (5) for each id, and calculate the average. Therefore, the total time complexity is O(knlogn). Space used here besides the ouput is the map that used to store data, which is O(n). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * public class Record &#123; * public int id, score; * public Record(int id, int score)&#123; * this.id = id; * this.score = score; * &#125; * &#125; */public class HighFive &#123; /** * @param results * @return */ public Map&lt;Integer, Double&gt; highFive(Record[] results) &#123; if (results == null) &#123; return new HashMap&lt;&gt;(); &#125; Map&lt;Integer, Double&gt; map = new HashMap&lt;&gt;(); Map&lt;Integer, PriorityQueue&lt;Integer&gt;&gt; score = new HashMap&lt;&gt;(); for (Record record : results) &#123; if (!score.containsKey(record.id)) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1 &gt; o2 ? -1 : o1 == o2 ? 0 : 1; &#125; &#125;); pq.offer(record.score); score.put(record.id, pq); &#125; else &#123; score.get(record.id).offer(record.score); &#125; &#125; for (Map.Entry&lt;Integer, PriorityQueue&lt;Integer&gt;&gt; pair : score.entrySet()) &#123; PriorityQueue&lt;Integer&gt; pq = pair.getValue(); int count = 0; double sum = 0; while (!pq.isEmpty() &amp;&amp; count &lt; 5) &#123; sum += pq.poll(); count++; &#125; map.put(pair.getKey(), sum / count); &#125; return map; &#125;&#125;]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure IV Queue]]></title>
    <url>%2F2018%2F05%2F05%2FData-Structure-IV-Queue%2F</url>
    <content type="text"><![CDATA[QueueA first in First out(FIFO) linear data structure. It allows insertion from onside and deletion from the other. Peek represents the first element added into the queue. Use to deal with process that has to be executed in a line. LinkedListImplement a queue with basic operations using linked list. Keep two references head and tail. Enqueue from the tail of the list, beacuse the head if the first element added in. Thus, dequeue from the head of the list. Time complexity for enqueue and dequeue are both O(1). Space complexity is O(1) beacuse only refernces are used.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyQueueLL &#123; /** * public class ListNode&lt;Integer&gt;&#123; * public Integer val; * public ListNode next; * public ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; */ private ListNode head; private ListNode tail; int size; public MyQueueLL() &#123; head = tail = null; &#125; public void enqueue(Integer e) &#123; ListNode node = new ListNode(e); if (tail == null &amp;&amp; head == null) &#123; head = tail = node; &#125; tail.next = node; tail = tail.next; size++; &#125; public Integer dequeue() &#123; if (head == null) &#123; return null; &#125; ListNode node = head; head = head.next; size--; return node.val; &#125; public Integer peek() &#123; return head == null ? null : head.val; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; Circular ArrayImplement a queue by using an array. cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. Using two pointers head and tail to represent two ends of the queue. If head == tail, the queue is either empty or full. Since the queue has its capacity, it needs a method to check whehter is full. The time complexity ans space complexity for enqueue and dequeue are both O(1). Data used here is just an Integer array. 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyQueueArr &#123; Integer head; Integer tail; int size; Integer[] array; public MyQueueArr(int cap) &#123; array = new Integer[cap]; size = 0; head = tail = 0; &#125; public boolean enqueue(int e) &#123; if (size == array.length) &#123; return false; &#125; array[tail] = e; tail = tail + 1 == array.length ? 0 : tail + 1; return true; &#125; public Integer dequeue() &#123; if (size == 0) &#123; return null; &#125; Integer result = array[head]; head = (head + 1) % array.length; size--; return result; &#125; public int size () &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public boolean isFull() &#123; return size == array.length; &#125;&#125; Circular array initializes a capacity, and linked list doesnâ€™t have the problem. Therefore, the use case for implementing queue by using array and linked list is that when the capacity of the queue is definite, using circurlar array. Otherwise, linked list is more flexible on the size of queue.]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure VI Graph II]]></title>
    <url>%2F2018%2F05%2F05%2FData-Structure-VI-Graph-II%2F</url>
    <content type="text"><![CDATA[A directed graph (or digraph) is a set of vertices and a collection of directed edges that each connects an ordered pair of vertices. We say that a directed edge points from the first vertex in the pair and points to the second vertex in the pair1. Directed GraphTopological sortGiven a digraph, put the vertices in order such that all its directed edges point from a vertex earlier in the order to a vertex later in the order (or report that doing so is not possible). Remarkably, a reverse postorder in a DAG provides a topological order2. Proposition: A digraph has a topological order if and only if it is a DAG. Proposition: Reverse postorder in a DAG is a topological sort3. Applications: order of items that have dependencies from each other. Steps: Get in-degrees, and initialize topoligical list. Generate all elements that have 0 in-degree into queue. Expand elements and add into topological list. Reduce 1 in-degree from expanded elements. If in-degree of an element becomes 0, put into queue. If queue is empty, return.Time complexity is O(E + V) where E is edges and V is vertices. Space complexity is O(E) beaucse using queue123456789101112131415161718192021222324252627282930313233343536373839public class TopologicalSort &#123; public ArrayList&lt;DirectedGraphNode&gt; sort(ArrayList&lt;DirectedGraphNode&gt; graph) &#123; if (graph == null) &#123; return new ArrayList&lt;&gt;(); &#125; HashMap&lt;DirectedGraphNode, Integer&gt; map = new HashMap&lt;&gt;(); for (DirectedGraphNode node : graph) &#123; for (DirectedGraphNode nei : node.neighbors) &#123; if (map.containsKey(nei)) &#123; map.put(nei, map.get(nei) + 1); &#125; else &#123; map.put(nei, 1); &#125; &#125; &#125; ArrayList&lt;DirectedGraphNode&gt; list = new ArrayList&lt;&gt;(); Queue&lt;DirectedGraphNode&gt; queue = new ArrayDeque&lt;&gt;(); for (DirectedGraphNode node : graph) &#123; if (!map.containsKey(node)) &#123; queue.offer(node); list.add(node); &#125; &#125; while (!queue.isEmpty()) &#123; DirectedGraphNode cur = queue.poll(); for (DirectedGraphNode node : cur.neighbors) &#123; map.put(node, map.get(node) - 1); if (map.get(node) - 1 == 0) &#123; queue.offer(node); list.add(node); &#125; &#125; &#125; return list; &#125;&#125; 1.Sedgewick, Robert, and Kevin Daniel Wayne. Algorithms. Addison-Wesley, 2015. â†©2.Sedgewick, Robert, and Kevin Daniel Wayne. Algorithms. Addison-Wesley, 2015. â†©3.Sedgewick, Robert, and Kevin Daniel Wayne. Algorithms. Addison-Wesley, 2015. â†©]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç”Ÿæ—¥]]></title>
    <url>%2F2018%2F05%2F04%2F%E7%94%9F%E6%97%A5%2F</url>
    <content type="text"><![CDATA[ä»Šå¹´çš„ç”Ÿæ—¥, æƒ³åšä¸€ç‚¹ä¸ä¸€æ ·çš„äº‹æƒ…, ä¿ç•™ä¸€ç‚¹ç‚¹çš„ä»ªå¼æ„Ÿ. ä»Žæˆ‘è®°äº‹å„¿å¼€å§‹, å®¶é‡Œçš„é£Ÿç‰©æ€»æ˜¯åˆ†æˆâ€å¤§äººçš„â€å’Œâ€å°å­©å­çš„â€. æ¯”å¦‚æˆ‘çš„é¦’å¤´, åŒ…å­, é¥ºå­, é¦…å„¿é¥¼ä¸ªå¤´å„¿éƒ½æ¯”è¾ƒå°; æˆ‘å–œæ¬¢çš„è”¬èœå’Œè‚‰çš„ç§ç±»ä¼šæ”¾åœ¨æˆ‘è‡ªå·±çš„ç¢—ç›˜é‡Œé¢, å°å·§åˆç²¾è‡´. å…¶å®žæ˜¯çˆ¶æ¯ä¸ºäº†è§£å†³æˆ‘å°æ—¶å€™ä¸çˆ±åƒé¥­çš„ä¸€ç§æ–¹å¼. åŽæ¥æ¸æ¸äº†, æˆ‘è‡ªå·±ä¹Ÿå…»æˆäº†è¿™æ ·çŸ«æƒ…çš„æ¯›ç—…. ä¸€ç›´åˆ°çŽ°åœ¨, æ¯äº²åŒ…é¥ºå­ä¾ç„¶æ˜¯å…ˆåŒ…ä¸€éƒ¨åˆ†å°å°çš„ç»™æˆ‘, ç„¶åŽå†åŒ…æ­£å¸¸å°ºå¯¸çš„. è¿™æ˜¯æˆ‘ä¸€ç›´ä»¥æ¥çŸ¥é“çš„ç»†èŠ‚, å› ä¸ºä¹ æƒ¯äº†, ä¹Ÿå› ä¸ºæˆ‘æœ¬èº«æ˜¯ä¼šåšé¥­çš„, æ‰€ä»¥ä¹Ÿæ²¡è§‰å¾—æœ‰ä»€ä¹ˆ. å°çš„æ—¶å€™, çˆ¶æ¯äº²å·¥ä½œå¿™, æ‰€ä»¥æˆ‘å·®ä¸å¤šä¸Šå°å­¦çš„æ—¶å€™å°±å·²ç»ä¼šåšé¥­äº†. åŒ…é¥ºå­è¿™äº‹å„¿è‡ªç„¶ä¹Ÿä¸åœ¨è¯ä¸‹. å¯æ˜¯æˆ‘ä»Žæ¥æ²¡æœ‰ç‹¬ç«‹çš„åšå®Œè¿‡æ•´ä¸ªæµç¨‹. å› ä¸ºè§‰å¾—éº»çƒ¦, ä¹Ÿå› ä¸ºå½“æˆ‘è§‰å¾—éº»çƒ¦åˆæƒ³åƒé¥ºå­çš„æ—¶å€™çˆ¶æ¯äº²æ€»ä¼šæŠŠé¥ºå­ç…®å¥½ç«¯ä¸Šæ¡Œ. åŽ»å¹´, â€œæ€•éº»çƒ¦â€è¿™ä¸ªä¹ æƒ¯, ç»ˆäºŽè¿˜æ˜¯è®©æˆ‘åƒäº†ä¸€å ‘. æˆ‘å†³å®šè¦æ”¹æŽ‰è¿™ä¸ªåä¹ æƒ¯. å°±ä»Žè¿™ä»¶å°äº‹å„¿å¼€å§‹. äºŽæ˜¯æˆ‘åŽ»è¶…å¸‚ä¹°äº†ææ–™, è‡ªå·±ä»Žå’Œé¢, æ‹Œé¦…å„¿, åˆ°æ“€çš®å„¿, åŒ…é¥ºå­. æ•´æ•´ç«™ç€å¿™äº†3ä¸ªåŠé’Ÿå¤´, æ²¡æœ‰åœä¸‹æ¥è¿‡. ä»¥è‡³äºŽæœ‰é‚£ä¹ˆä¸€å°æ®µæ—¶é—´ç´¯çš„è€³é¸£. ä¸€å¼€å§‹è¿˜èƒ½æŒ‰ç…§è‡ªå·±çš„çˆ±å¥½, åŒ…ä¸€äº›å°å·§å¯çˆ±çš„, ä¿æŒé¥ºå­æ•´ä½“çš„å¹²å‡€æ•´æ´. å·®ä¸å¤šåŒ…åˆ°ä¸€åŠçš„æ—¶å€™æ˜Žæ˜¾æ„Ÿè§‰é¥ºå­çš„ä¸ªå¤´å„¿è¶Šæ¥è¶Šå¤§, é¦…å„¿éƒ½æ²¾åˆ°å¤–é¢äº†ä¹Ÿæ‡’å¾—åŽ»æ¸…ç†äº†. å¿ƒé‡Œä»…å­˜çš„å¿µå¤´æ˜¯â€èµ¶ç´§æŠŠå‰©ä¸‹çš„é¦…å„¿åŒ…å®Œâ€. çˆ¶æ¯çš„çˆ±éƒ½æ˜¯åœ¨ç¨€æ¾å¹³å¸¸çš„ä¸€é¤ä¸€é¥­ä¸­. è¿™æ ·çœ‹ä¼¼ç®€å•çš„äº‹æƒ…, ä»–ä»¬ä¸ºäº†æˆ‘åšæŒäº†äºŒåå¤šå¹´. å“ªæœ‰ä»€ä¹ˆçŽ°ä¸–å®‰ç¨³, ä¸è¿‡æ˜¯å› ä¸ºæœ‰äººä¸ºä½ è´Ÿé‡å‰è¡Œ.]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Observer Pattern]]></title>
    <url>%2F2018%2F04%2F29%2FObserver-Pattern%2F</url>
    <content type="text"><![CDATA[è§‚å¯Ÿè€…æ¨¡å¼: å®šä¹‰å¯¹è±¡é—´çš„ä¸€ç§ä¸€å¯¹å¤šçš„ä¾èµ–å…³ç³», å½“ä¸€ä¸ªå¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶, æ‰€æœ‰ä¾èµ–äºŽå®ƒçš„å¯¹è±¡éƒ½å¾—åˆ°é€šçŸ¥å¹¶è‡ªåŠ¨æ›´æ–°1. æˆ‘çš„ç†è§£æ˜¯, æ¯ä¸€ä¸ªç±»éƒ½å¯ä»¥æ´¾ä¸€ä¸ªå“¨å…µ, ä¹Ÿå°±æ˜¯è§‚å¯Ÿè€…åŽ»ç›®æ ‡ç±»è¿›è¡Œå§åº•, ä¸€æ—¦ç›®æ ‡çŠ¶æ€å‘ç”Ÿå˜åŒ–æˆ–è€…æœ‰ä»»ä½•åŠ¨ä½œ, å“¨å…µè´Ÿè´£æŠŠçŠ¶æ€è¿”å›ž. å°±åƒå°æ—¶å€™æ¯ä¸ªç­éƒ½æœ‰ä¸€ä¸ªååœ¨åŽé—¨çœ‹æ”¾å“¨çš„åŒå­¦. ç›®æ ‡ç±»å¯ä»¥ç»§æ‰¿å¤šä¸ªè§‚å¯Ÿç±», å¯¹äºŽåŒä¸€ä¸ªç›®æ ‡çš„çŠ¶æ€æ”¹å˜, ä¸åŒçš„è§‚å¯Ÿç±»å¯ä»¥è¿”å›žä¸åŒçš„çŠ¶æ€, ä»Žè€Œè¾¾åˆ°å¯¹äºŽåŒä¸€ä¸ªç›®æ ‡äº§ç”Ÿå¤šä¸ªä¸åŒçš„å“åº”. ç›®æ ‡ä¸éœ€è¦é€šçŸ¥å“¨å…µ, å®ƒçš„çŠ¶æ€å‘ç”Ÿå˜åŒ–äº†, è€Œæ¯ä¸ªå“¨å…µä¹‹é—´çš„å…³ç³»ä¹Ÿæ˜¯ç›¸å¯¹ç‹¬ç«‹çš„, ä»Žè€Œè¾¾åˆ°äº†å‡å°‘è€¦åˆçš„æ•ˆæžœ. è¿™ç§è®¾è®¡æ¨¡å¼é€‚ç”¨äºŽ, ä¸€ä¸ªå¯¹è±¡çš„æ”¹å˜ä¼šå½±å“åˆ°å…¶ä»–å¯¹è±¡, ä½†æ˜¯ä¸çŸ¥é“å…·ä½“æœ‰é‚£äº›å¯¹è±¡æˆ–è€…æœ‰å¤šå°‘å¯¹è±¡ä¼šå—åˆ°å½±å“. æ‰€ä»¥è¿™äº›å¯¹è±¡ä¹‹é—´çš„å…³ç³»ä¸èƒ½å¤Ÿæ˜¯ç›¸äº’ä¾èµ–çš„. ç›®æ ‡ç±»éœ€è¦åšçš„äº‹æƒ…å°±æ˜¯: ç»§æ‰¿è§‚å¯Ÿç±». å¢žåŠ /åˆ é™¤å°†ä¼šå—åˆ°å½±å“çš„å¯¹è±¡. (å¢žåŠ åˆ é™¤å¯¹è±¡çš„æ—¶å€™ä¸å½±å“å…¶ä»–è§‚å¯Ÿè€…) è§‚å¯Ÿç±»éœ€è¦åšçš„äº‹æƒ…å°±æ˜¯: æä¾›ä¸€ä¸ªé€šçŸ¥æ›´æ–°çš„æŽ¥å£. è¿™æ ·å°±å¯ä»¥å®žçŽ°, é‡å¤ä½¿ç”¨ç›®æ ‡ç±»å’Œè§‚å¯Ÿç±», è€Œä¸å½±å“å…¶ä»–å¯¹è±¡. æœ€æ—©çš„å¯èƒ½ä¹Ÿæ˜¯æœ€è‘—åçš„ Observer æ¨¡å¼çš„ä¾‹å­å‡ºçŽ°åœ¨ SmallTalk çš„ MVC ç»“æž„ä¸­,å®ƒæ˜¯ SmallTalk çŽ¯å¢ƒ[KP88] ä¸­çš„ç”¨æˆ·ç•Œé¢æ¡†æž¶. MVC çš„ Model ç±»æ‹…ä»»ç›®æ ‡çš„è§’è‰², è€Œ View ç±»æ˜¯è§‚å¯Ÿè€…çš„ base class. SmallTalk, ET++[WGM88], å’Œ THINK ç±»åº“[sym93b]éƒ½å°† Subject å’Œ Observer çš„æŽ¥å£æ”¾å…¥ç³»ç»Ÿæ‰€æœ‰å…¶ä»–ç±»çš„çˆ¶ç±»ä¸­, ä»Žè€Œæä¾›ä¸€ä¸ªé€šç”¨çš„ä¾èµ–æœºåˆ¶. å…¶ä»–ä½¿ç”¨è¿™ä¸€æ¨¡å¼çš„ç”¨æˆ·ç•Œé¢å·¥å…·æœ‰ InterViews[LVC89], AndrewToolkit[p+88] å’Œ Unidraw[VL90]. InterViews æ˜¾ç¤ºåœ°å®šä¹‰äº† Observer(è§‚å¯Ÿç±») å’Œ Observable (ç›®æ ‡ç±»). Andrew åˆ†åˆ«ç§°å®ƒä»¬ä¸ºâ€è§†å›¾â€å’Œâ€æ•°æ®å¯¹è±¡â€. Unidraw å°†å›¾å½¢ç¼–è¾‘å™¨å¯¹è±¡åˆ†å‰²æˆ View å’Œ Subject ä¸¤éƒ¨åˆ†2. å®‰å“ç•Œé¢ä¸­å¤§é‡çš„ä½¿ç”¨äº† Observer, é€šè¿‡ç»§æ‰¿ activity å’Œ Fragment çš„è§‚å¯Ÿç±», ä¸»ç¨‹åºçŠ¶æ€ä¼šè¢«åœ¨ä¸åŒçš„ç»„ä»¶è¿›è¡Œæ›´æ–°.]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Observer Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Search]]></title>
    <url>%2F2018%2F04%2F25%2FBinary-Search%2F</url>
    <content type="text"><![CDATA[Binary search is a search algorithm. The fundamental is that it reduces the searching range into half each time by comparing the middle element to the target. Normal binary search takes O(logn) comparisons, when n is the number of input. Space actually depends on the implementation. If not using recursion, there would be no extra space used in a regular binary search. Therefore, it normally is O(1). Key concept: Input must be in some sort of order (ascending, descending, alphabetic, positve and nagative, increased then descrease, etc.) Searching/calculation/operating range must be reduced each time. Targe must not be ruled out. Classic Binary Searchinput: A sorted array and a target.output: Index of the target if exits, otherwise, return -1; IterationTime complexity is O(logn), where n is the size of input. Space is O(1) using iteration.12345678910111213141516171819202122232425public class BinarySearch &#123; /** * @param array * @param target * @return */ public int binarySearch (int[] array, int target) &#123; if (array == null || array.length == 0) return -1; int left = 0, right = array.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (array[mid] == target) &#123; return mid; &#125; //other wise mid is not the result, rule it out. if (array[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; //if not return in the while loop, target doesn't exist. return -1; &#125;&#125; RecursionTime complexity is the same as O(logn). Call stack counts as space expense, which is O(logn). 12345678910111213141516171819202122232425public class BinarySearch &#123; /** * @param array * @param target * @return */ public int binarySearch (int[] array, int target) &#123; if (array == null || array.length == 0) return -1; return helper(array, 0, array.length - 1, target); &#125; private int helper(int[] array, int left, int right, int target) &#123; if (left &gt; right) return -1; int mid = left + (right - left) / 2; if (array[mid] == target) return mid; //if not return, mid is not target, can rule out mid. if (array[mid] &gt; target) &#123; return helper(array, left, mid - 1, target); &#125; else &#123; return helper(array, mid + 1, right, target); &#125; &#125;&#125; Search a 2D Matrix Iinput: A matrix that each row is in ascending order, and the first element of each row is greater than the last element of previous row. A int type target.output: The coordinate of the target if exists. Otherwise, return -1. One way to solve this problem by using binary search is convert 2D matrix into an array. Due to the property of the matrix, from left to right, top to buttom, all elements are in ascending order. Therefore, it will be able to use the classic binary search. The time complexity is O(n + m) where n is the number of row and m is the number of colmun. Space complexity is O(1). No extra data structure is used. 12345678910111213141516171819202122232425262728public class Search2DMatrix &#123; /** * @param matrix * @param target * @return */ public int searchMatrixI (int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) return -1; int row = matrix.length; int column = matrix[0].length; int left = 0, right = row * column - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; int x = mid / column, y = mid % column; if (matrix[x][y] == target) &#123; return matrix[x][y]; &#125; if (matrix[x][y] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1; &#125;&#125; Search in a Unknown Size Arrayinput: An unknwon size array in ascending order, you can only access the kth number by ArrayReader.get(k). A target number.output: return the first occurrence of the target. Only thing differnce from classic bianry search is right boundary. While checking the right boundary, set the left boundary where is the last position that the element is smaller than the target. Jumping 2 times of the current element to locate the right boundary, then the time complexity is O(logk + O(logn)) where k is the element from the left boundary to the right boundary, n is the number of elements preceding the left boundary.The only reason jumping 2 times instead of a larger one is beacuse the final time complexity is difference only in coefficient. The size is unknwon. If there are only a few of elements in the array, jumping 10 times or 20 times would be out of bounds. It is not worth to take the risk. 1234567891011121314151617181920212223242526272829303132public class SearchUnknownSize &#123; /** * @param reader: An instance of ArrayReader. * @param target: An integer * @return: An integer which is the first index of target. */ public int searchBigSortedArray(ArrayReader reader, int target) &#123; if (reader == null) &#123; return -1; &#125; //locate right boundary int right = 1; int left = 0; while (reader.get(right - 1) &lt; target) &#123; right *= 2; left = right; &#125; //binary search for first occurrence while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (reader.get(mid) &gt;= target) &#123; right = mid; &#125; else if (reader.get(mid) &lt; target) &#123; left = mid + 1; &#125; &#125; if (reader.get(left) == target) return left; if (reader.get(right) == target) return right; return -1; &#125;&#125; First Bad LogThe concept is using binary search to find the left and right boundary, and locate the first occurrence of the bad log. Search Insert Positioninput: an integer array and a target number.output: return the index if the target is found. If not, return the index where it would be if it were inserted in order. It is easier to find a closest number to the target, then compare the element to the target, insert target at the position it if the element is greater or equal to the target. insert target after the position if the element is smaller than the target. The time comlexity is O(logn). Space complexity is O(1). 1234567891011121314151617181920212223242526272829303132public class searchInsert &#123; /** * @param input: an integer sorted array * @param target: an integer to be inserted * @return: An integer */ public int searchInsert(int[] input, int target) &#123; // write your code here if (input == null || input.length == 0) &#123; return 0; &#125; int left = 0; int right = input.length - 1; //keep one element for comparing to the target. while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &gt;= target) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; if (input[left] &gt;= target) &#123; return left; &#125; return left + 1; &#125;&#125; First Occurrence of Targetinput: an sorted int array in ascending orderoutput: index of the first occrrence of the target. If not exist, return -1;Iâ€™d like call it look to the left. Using binary search, if greater or equal, set the right boundary at the position. If less than the target, the element is excluded from searching range.Time comlexity is O(logn), space is O(1). 12345678910111213141516171819202122public class FirstOccurrence &#123; /** * @param input * @param target * @return first occurrence of the target */ public int firstOccurrence(int[] input, int target) &#123; if (input == null) return -1; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &gt;= target) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; if (input[left] == target) return left; return right; &#125; &#125; Last Occurrence of Targetinput: an sorted int array in ascending orderoutput: index of the last occurrence of the target. If not exisit, return -1. Iâ€™d like call it look to the right. Similar to first occurrance. Only difference is if the element at the middle is less than or equal to the target, set the left boundary, because right result must be in the range from the position to the end. If the middle element is greater than the target, it is eliminated from the result. Time comlexity is O(logn), space is O(1).12345678910111213141516171819202122public class LastOccurrence &#123; /** * @param input * @param target * @return first occurrence of the target */ public int lastOccurrence(int[] input, int target) &#123; if (input == null) return -1; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &lt;= target) &#123; left = mid; &#125; else &#123; right = mid - 1; &#125; &#125; if (input[right] == target) return right; return left; &#125;&#125; Total Occurrence of Targetinput: an int array in ascending order and a target number.output: return the total occurrence of the target. One way to do it is, targeting either the first occurrence or the last occurrence of the target. The look throught it and count. The time complexity would be O(logn) for finding the position and O(k) for looping the number of target, so it is O(logn + k). Space comlexity is O(1). Another way of calculating the number of target in the array is to get both first occurrence and the last occurrence of the larget. Using the last position minus the first position and plus 1 to get the total number of target in the array. The time complexity is O(2logn). Space Comlextiy is O(1). Which ways is bettern actually depending on the number of target, k. If all elements in the array are the same numbers. For example, {1, 1, 1, â€¦, 1, 1}. The first method becomes O(n). The second method remains the same. However, if k is a really small number, then the first method is better.1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TotalOccurrence &#123; /** * @param input: an integer array sorted in ascending order * @param target: An integer * @return: An integer */ public int totalOccurrence(int[] input, int target) &#123; if (input == null || input.length == 0 || input[0] &gt; target || input[input.length - 1] &lt; target) &#123; return 0; &#125; int left = 0, right = input.length - 1; //left boundary while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &gt;= target) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; //é€€å‡ºæ¡ä»¶æ˜¯ä¸€ä¸ªå…ƒç´ , å¦‚æžœä¸ç­‰äºŽ target, åˆ™ target ä¸å­˜åœ¨. if (input[left] != target) return 0; //left boundary and right boundary int start = left, end = input.length - 1; //right boundary right = end; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &lt;= target) &#123; left = mid + 1; end = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return end - start + 1; &#125;&#125; Search for a RangeAs same as total occurance, only changes the return type to a new int[]{start, end}.Time and space comlexity are the same, too. Closest Number to Targetinput: An integer array and an integer target number.output: return the number that closest to the target. Time complexity is O(logn). Space complexity is O(1). Using binary search and reducing the candidate to two elements. Whichever closer to target is the result.123456789101112131415161718192021222324public class ClosestNumber &#123; /** * @param input an integer array sorted in ascending order * @param target an integer * @return an integer */ public int closestNumber(int[] input, int target) &#123; if (input == null || input.length == 0) &#123; return -1; &#125; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &lt;= target) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; return Math.abs(input[left] - target) &lt; Math.abs(input[right] - target) ? left : right; &#125;&#125; Search in Rotated Sorted Array Iinput: a sorted array is rotated at some unknown pivot and a target number. (No duplicates)output: return the index of target if exists. Otherwise, return -1. Since the array is still sorted in a way, it still can use binary search. The middle element has 3 situations: it is the target it is in an rotated interval (greater than the right most element) it is greater than the target, target could be in both side of the array. it is less than target, set the left boundary. it is in an unrotated interval (smaller than the right most element) it is greater than the target, set the right boundary. it is less than the target, target could be in both side of the array.This problem actually would be more straitforwar if looking at a picture. The time complexity is as same as classic binary search, O(logn), although it has more conditions. Space complexity is O(1).1234567891011121314151617181920212223242526272829303132333435363738public class RoatedSortedArrayI &#123; /** * @param input * @param target * @return */ public int search(int[] input, int target) &#123; if (input == null || input.length == 0) &#123; return -1; &#125; int left = 0, right = input.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (input[mid] == target) &#123; return mid; &#125; //ç¬¬ä¸€ä¸ªä¸Šå‡åŒºé—´ if (input[mid] &gt; input[right]) &#123; if (input[mid] &gt; target &amp;&amp; target &gt; input[right]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; //ç¬¬äºŒä¸ªä¸Šå‡åŒºé—´ if (input[mid] &lt; input[left]) &#123; if (input[mid] &lt; target &amp;&amp; target &lt; input[left]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; Search in Rotated Sorted Array IIinput: rotated array with duplicates.output: index of target. Fist of all, run a for loop searching target takes O(n). If the array is rotated with duplicates, it takes redundant checks to determine whether the middle point is in which interval. For example, {1, 1, 1, 1, 1, 0, 1, 1, 1}. The time complexity would be O(n) the worst case. Therefore, just simply run a loop. 123456789101112131415161718192021public class SearchRotateArrayII &#123; /** * @param input: an integer ratated sorted array and duplicates are allowed * @param target: An integer * @return: index */ public int search(int[] input, int target) &#123; if (input == null) &#123; return -1; &#125; for (int i = 0; i &lt; input.length; i++) &#123; if (input[i] == target) &#123; return i; &#125; &#125; return -1; &#125;&#125; Find Peak Elementinput: An integers array that the numbers in adjacent positions are different. A[0] &lt; A[1] &amp;&amp; A[A.length - 2] &gt; A[A.length - 1]. Peak in an array: A[P] &gt; A[P-1] &amp;&amp; A[P] &gt; A[P+1]output: return any of peek positions. There might be more than one peeks. According to the definition of the peek and the arrayâ€™s feature. Returning any peek can use a binary saerch. Since the array is kind of sorted, the middle point would have three situations. middle point is the peek middle point is in the left side of a peek, then itâ€™s in ascending order (like going uphill) middle point is in the right side of a peek, then itâ€™s in descending order (like going downhill) Time comlexity is O(logn). Space complexity is O(1). If using â€˜left + 1 &lt; rightâ€™ as the condition of the while loop, it eliminates many checkings for index out of bounds excemption. The element always needs to compare with its neighbor, so itâ€™s easier to keep at least three elements during the comparing. Making sure that the peek would not be ruled out guarantees the greater element to be the peek when finishing the loop. 12345678910111213141516171819202122232425262728293031public class FindPeek &#123; /** * @param input: An integers array. * @return: return any of peek positions. */ public int findPeak(int[] input) &#123; if (input == null || input.length &lt; 3) &#123; return -1; &#125; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; /*if (input[mid] &gt; input[mid - 1] &amp;&amp; input[mid] &gt; input[mid + 1]) &#123; return mid; &#125;*/ //at ascending interval if (input[mid] &gt; input[mid - 1]) &#123; left = mid; &#125; //at descending interval if (input[mid] &lt; input[mid - 1]) &#123; right = mid; &#125; &#125; if (input[left] &gt; input[right]) &#123; return left; &#125; return right; &#125;&#125; Maximum Number in Mountain Sequenceinput: An integer array which increase firsly and then decreses.output: return the mountain top. Actually the same question as find peek. T = O(logn), S = O(1). Comparing an element to its neighbor is always easier to keep at least 3 elements. It saves many index boundary check. Notice that left or right boundary could be the candidate of the result, it should not be eliminated. 12345678910111213141516171819202122232425public class MountainTop &#123; /* * @param input: a mountain sequence which increase firstly and then decrease * @return: then mountain top */ public int mountainSequence(int[] input) &#123; if (input == null || input.length == 0) &#123; return 0; &#125; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &lt; input[mid + 1]) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; return Math.max(input[left], input[right]); &#125;&#125; Find Minimum in Rotated orted Array IThis question is actually as same as finding the peek. Find Minimum in Rotated orted Array IIAs same as duplicates in a rotated sorted array, it is not worth to use binary search with all redundant checks. Single Number IVinput: an int array with all the numbers appear twice except one number which appears once and all the numbers which appear twice are next to each other.output: find the number that appears once. æ‰¾å‡ºå•èº«ç‹—ðŸ¤£ Intuitive way is using a set. Beacuse of the property of set, if there exisit the element, remove the element. The one left in the set would be the result. Time comlexity is O(n), and space complexity is about O(n) during the comparing. However, this would waste the clue that â€œsame numbers appear next to each otherâ€. Since the intutitive way takes only O(n), optimized method ought to be better than that. Since there is only 1 missing number, then the number element of the input must be odd.There are 2 cases of the middle number. the middle number is the missing number. the middle number has an ajacent duplicate number. The adjacent number with the same value is in the left side. the adjacent number with the same value is in the right side. The key point is, the side that has the odd number of element after eliminating the middle pair has the missing number. Time comlexity is O(logn). Space comlexity is O(1).1234567891011121314151617181920212223242526272829303132333435public class MissingNumberIV &#123; /** * @param nums * @return the lonely number */ public int getSingleNumber(int[] nums) &#123; if (nums == null || nums.length == 0 || nums.length % 2 == 0) return -1; if (nums.length == 1) return nums[0]; //if not return, the array has at lest 3 elements. int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; //å’Œå³è¾¹ç›¸ç­‰çš„è¯, å³è¾¹å‡åŽ»1 æ˜¯ä¸æ˜¯å¶æ•° if (nums[mid] == nums[mid + 1]) &#123; if ((right - mid - 1) % 2 == 0) &#123; right = mid - 1; &#125; else &#123; left = mid + 2; &#125; &#125; else if (nums[mid] == nums[mid - 1]) &#123; if ((mid - left - 1) % 2 == 0) &#123; left = mid + 1; &#125; else &#123; right = mid - 2; &#125; &#125; else &#123; return nums[mid]; &#125; &#125; return nums[left];/// &#125;&#125; Power(x, n)input: two integers.output: return the power of the first number. There are several cases need to concern in the arithmetical opeation: overflow base is 0 if exponent &lt;= 0, error if exponent &gt; 0, return 0 exponent is 0, return 1 exponent is negative, 1 / result exponent is positive, exponent is even number exponent is odd number Using recursion to reduce the power. a to the power of b can be divided into a to the half of power of b times a to the half of power of b. And so on and so forth. The complexity is O(logb). Space compexity is O(logb) due to the call stack. 123456789101112131415161718192021222324252627282930public class PowerAB &#123; /** * @param a * @param b * @return */ public double power (int a, int b) &#123; if (a == 0) &#123; if (b &lt;= 0) &#123; throw new IllegalArgumentException("Illegal input"); &#125; return 0; &#125; if (b &lt; 0) &#123; return 1 / helper(a, -b); &#125; return helper(a, b); &#125; private double helper(int a, int b) &#123; if (b == 0) &#123; return 1; &#125; double half = helper(a, b / 2); if (b % 2 == 0) &#123; return half * half; &#125; return half * half * a; &#125;&#125; Divide Two Integersinput: two itnegersoutput: divide two integers without using multiplications, division and modulo. Using divisor to reduce the number of dividend to get the result. Counting how many dividend has been detracted1. Similar as doing power of two integers, using binary concept to accelerate the process2. Time complexity is O(logn) where n is the divisor and the space complexity is O(1). 123456789101112131415161718192021222324252627282930313233343536373839public class DivideTwoIntegers &#123; /** * @param dividend * @param divisor * @return */ public int divide(int dividend, int divisor) &#123; if (dividend == 0) &#123; throw new IllegalArgumentException("Dividend cannot be 0."); &#125; if (divisor == 0) &#123; return dividend &lt; 0 ? Integer.MIN_VALUE : 0; &#125; if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123; return Integer.MAX_VALUE; &#125; boolean isNegative = (dividend &lt; 0 &amp;&amp; divisor &gt; 0 || dividend &gt; 0 &amp;&amp; divisor &lt; 0); long absDividend = Math.abs((long) dividend); long absDivisor = Math.abs((long) divisor); long result = 0; while (absDividend &gt;= absDivisor) &#123; int shift = 0; while (absDividend &gt;= (divisor &lt;&lt; shift)) &#123; shift++; &#125; dividend -= divisor &lt;&lt; (shift - 1); result += 1 &lt;&lt; (shift - 1); &#125; return isNegative ? (int) -result : (int) result; &#125;&#125; Find Smallest Letter Greater Than Target (LeetCode 744)input: a char array of sorted letters containing only lowercase letters, and given a target letter target.output: return the smallest element in the list that is larger than the given target. Letters are ordered is ideal for binary search. Time complexity is O(logn). Space is O(1). Keep one element that is greater than the target. If the characters is less than or equal to target, target must closer to the first element in the array. Otherwise, the character is the result. 1234567891011121314151617181920212223public class SmallestGreaterLetter &#123; /** * @param letters * @param target * @return */ public char nextGreatestLetter(char[] letters, char target) &#123; if (letters == null) return ' '; int left = 0, right = letters.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (letters[mid] &lt;= target) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; if (letters[left] &lt;= target) return letters[0]; return letters[left]; &#125;&#125; &lt;!â€“ ### Count of Smaller Numberinput: an integer array and a query list.output: return the number of element in the array that are smaller than the given number in the query. ç¶šãã€‚ 1.https://blog.csdn.net/fightforyourdream/article/details/16899675 â†©2.http://www.cnblogs.com/yuzhangcmu/p/4049170.html â†©]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emoji]]></title>
    <url>%2F2018%2F04%2F25%2FEmoji%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘ã€ç§ã¯çµµæ–‡å­—ã«è€½ã£ã¦ã„ã¦ã‹ã‚ã„ã„ã¨é¢ç™½ã„çµµæ–‡å­—ã‚’ãŸãã•ã‚“è¦‹ã¤ã‘ã¾ã—ãŸãŒã€å®Ÿéš›ã¯è¨€è‘‰ã‚„è¨˜å·ã§è¡¨ç¾ã•ã‚ŒãŸè¡¨ç¾ãªã®ã§ã€ã€Œmojieã€ã¨å‘¼ã¶æ–¹ãŒé©åˆ‡ã‹ã©ã†ã‹ã¯ã‚ã‹ã‚Šã¾ã›ã‚“ã§ã—ã‚‡ã†ã€‚(ËŠoÌ´Ì¶Ì·Ì¤âŒ„oÌ´Ì¶Ì·Ì¤Ë‹)ç§ã¯ã­ã€å®Ÿéš›ã¯ã€é•·ã„é–“æ—¥æœ¬èªžã‚’ä½¿ã„ã¾ã›ã‚“ã§ã—ãŸã€‚ã“ã‚Œã‚‰ã®æ–‡ç« ã‚’æ›¸ã„ãŸã“ã¨ã€å¤šãã®è¾žæ›¸ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã—ãŸãŒã€æ–‡æ³•ä¸Šã®å•é¡Œã¯ã¾ã ã‚ã‚‹ã¨æ€ã„ã¾ã™ã€‚ã¾ã‚ãã€ã„ã„ã€‚ãã‚Œã˜ã‚ƒã‚ã€œ ( Â¤Ì´Ì¶Ì·Ì€ Â·Ì« Â¤Ì´Ì¶Ì·Ì )(à¹‘Â¯â—¡Â¯à¹‘)(à¸‡ â€¢Ì€â€¢Ì)à¸‡(à¹‘à¥”áµ’Ì´Ì¶Ì·â—¡ Ë‚Ì¶à¹‘à¥“)ã‚žâ£à­§(à¹‘â€¢Ì€âŒ„â€¢Ìà¹‘)à«­âœ§âœ§à­§(à¹‘=Ì´Ì€âŒ„=Ì´Ìà¹‘)à«­âœ§âŠ‚(ËƒÌ¶Ì€ÍˆÎµ Ë‚Ì¶ÌÍˆ âŠ‚ )))Î£â‰¡=â”€âœ§âºâ¸œ(â—Ë™â–¾Ë™â—)â¸âºâœ§(à¹‘âœ¦Ë‘Ì«âœ¦)âœ¨à¹‘ä¹›â—¡ä¹›à¹‘â•®(à¹‘â€¢Ì â‚ƒâ€¢Ì€à¹‘)â•­(..â€¢Ë˜Ë˜â€¢..)(à¹‘áµ’Ì´Ì¶Ì·á·„Íˆá—¨áµ’Ì´Ì¶Ì·á·…Íˆ)(ï½¡â€¢Ë‡â€¸Ë‡â€¢ï½¡)(âŽâÌ´Ì›á´—âÌ´Ì›âŽ)(â€¢Ì¤Ì€áµ•â€¢Ì¤Ìà¹‘)áµ’áµáµŽáµŽáµŽáµŽà­§( â¼Ì´Ì¶Ì¤Ì€Ï‰â¼Ì´Ì¶Ì¤Ì )à«­]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Data Structure VI Graph I]]></title>
    <url>%2F2018%2F04%2F24%2FData-Structure-VI-Graph-I%2F</url>
    <content type="text"><![CDATA[A graph is formed by the non-empty set of vertex and set of edge. Use G &lt;E, V&gt; to represent a graph, G, and the sets of itâ€™s vertex, V, and edge, E. Undirected GraphA graph is a set of vertices and a collection of edges that each connect a pair of vertices Representation of Graph Data Structure (common) Ajacentcy Matrix: using a 2D array to indicate the relationship between vertex (row) and edge (column). Uses O(n^2) space for a sparse graph, not recommended. Ajacentcy List: Array of array to represent the relationship between the vertex (index), and the edge (array corresponds to the index). Even though the worst case of space using is still O(n^2), normally is better than ajacentcy matrix. Map&lt;T, Set&lt;T&gt;&gt;, where T is the vertext and Set is the set of edge. (Java) Class of GraphNode, which has two main field, the vertext and the list of its neighbors.(Java)1234class GraphNode&#123; int vertexLabel; List&lt;GraphNode&gt; neighbors;&#125; Traverse a Graphinput: A graph node, assume that the graph is connected.output: A list of all nodesâ€™ value in the graph. Unlike doing BFS on a tree, an extra data structure need to be used in traverse to avoid revisiting a node in a graph. Tree is a directed acyclic graph. If there are n nodes in a tree, there must be n - 1 edges, and every node can be visited from the root. Three main differences, A graph may or may not have direction. (better breadth first from one vertex) A graph may have circle. (markvisited) Nodes in a graph may not be connected. (all nodes must be given unless its connected) The data structure that widely used in BFS is queue, due to its FIFO property (in the order from left to right in a level). In a graph, node in the queue is the one that is waiting for expending. Meanwhile, set is saving all generated (visited/put in the queue) nodes. To sum, there are two common data structure involved in traversing a graph in general.(Java)Time complexity is O(v + e), where v is the number of vertex and e is the number of edge. Space is O(v), where v is the number of nodes because the worst case is to save all vertex. 12345678910111213141516171819202122232425262728293031public class Solution&#123; class GraphNode&#123; int label; List&lt;GraphNode&gt; neighbors; public GraphNode(int val) &#123; label = val; neighbors = new ArrayList&lt;GraphNode&gt;(); &#125; &#125; //Assume it's a connected graph public List&lt;Integer&gt; traverseGraph(GraphNode node) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (node == null) return result; Queue&lt;GraphNode&gt; queue = new LinkedList&lt;&gt;(); Set&lt;GraphNode&gt; visited = new HashSet&lt;&gt;(); queue.offer(node); visited.add(node); while (!queue.isEmpty()) &#123; GraphNode cur = queue.poll(); result.add(cur.label); for (GraphNode n : cur.neighbors) &#123; if (!visited.contains(n)) &#123; visited.add(n); queue.offer(n); &#125; &#125; &#125; return result; &#125;&#125; Clone Graphinput: A graph node, if the graph is connected, or a list of all nodes in the graph (easier).output: Deeped copyed node of new graph, or a list of all nodes that is copied. Similar to traverse a graph, except two more steps, Traverse the graph and get all nodes. (if not given) Copy all vertex(nodes) Copy all neighbors for every vertex. An extra data structure Map&lt;GraphNode, GraphNode&gt; is used here for mapping the original and copied node. Neighbors can be copied by tracing the key in the map. Time complexity is 3 times of traversal because at each step, all nodes need to be visited, so O(3(v + e)) is O(v + e).Space complexity is 2 times of traversal if list of node is not given. No matter the input form, the space complexity is going to be O(v), where v is the number of vertex. 1234567891011121314151617181920212223242526272829303132333435363738public GraphNode clone(GraphNode node) &#123; if (node == null) return null; //get node List&lt;GraphNode&gt; list = getNodes(node); //copy node, key is the original node, and create a same node as its value. Map&lt;GraphNode, GraphNode&gt; map = new HashMap&lt;&gt;(); for (GraphNode n : list) &#123; map.put(n, new Graph(n.label)); &#125; //copy neighbor/edge for (GraphNode ver : list) &#123; GraphNode newNode = map.get(ver); for (GraphNode nei : ver.neighbors) &#123; newNode.neighbors.add(map.get(nei)); &#125; &#125; return map.get(node); &#125;private List&lt;GraphNode&gt; getNodes(GraphNode node) &#123; Queue&lt;GraphNode&gt; q = new LinkedList&lt;&gt;(); Set&lt;GraphNode&gt; visited = new HashSet&lt;&gt;(); q.offer(node); visited.add(node); while(!q.isEmpty()) &#123; GraphNode cur = q.poll(); for (GraphNode nei : cur.neighbors) &#123; if (!visited.contains(nei)) &#123; q.offer(nei); visited.add(nei); &#125; &#125; &#125; return new ArrayList&lt;&gt;(visited);&#125; Sometimes, step/level/layer matters. Which means there needs to be a indicator for nodes that can be expanded from one. Just like BFS in a tree, use current size of the queue to detemine whether the nodes in the same level or not. There are other ways to indicate differnce levels in a graph, like two queues, indicator node, etc. I prefer more general way that can be used in both graph and tree. Traverse a Graph by Layerinput: A graph node, assume that the graph is connected.output: A list of list of all nodesâ€™ value in the graph. Code is pretty similar to regular traversal, only add a for loop to track the number of nodes at the same level.The time comlexity doesnâ€™t change. It is O(v + e), and the space is O(v) as same as traversal. 1234567891011121314151617181920212223242526272829303132333435363738public class Solution&#123; class GraphNode&#123; int label; List&lt;GraphNode&gt; neighbors; public GraphNode(int val) &#123; label = val; neighbors = new ArrayList&lt;GraphNode&gt;(); &#125; &#125; //Assume it's a connected graph public List&lt;List&lt;Integer&gt;&gt; traverseGraph(GraphNode node) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (node == null) return result; Queue&lt;GraphNode&gt; queue = new LinkedList&lt;&gt;(); Set&lt;GraphNode&gt; visited = new HashSet&lt;&gt;(); queue.offer(node); visited.add(node); while (!queue.isEmpty()) &#123; //size changes every time generates a node int size = queue.size(); List&lt;GraphNode&gt; level = new ArrayList&lt;&gt;(); //run loop for current size of the queue for (int i = 0; i &lt; size; i++) &#123; GraphNode cur = queue.poll(); level.add(cur.label); for (GraphNode n : cur.neighbors) &#123; if (!visited.contains(n)) &#123; visited.add(n); queue.offer(n); &#125; &#125; &#125; result.add(level); &#125; return result; &#125;&#125; There are more useful way of indicating levels while traversing. For example, find steps from one node to the other. Every level includes one more step towards to the target node. ShortestPath(monodirection)input: List of graph node, starting node, and target node. If given graph is not null, both start and end position are not null.output: Return the shortest path from the start to the target. If there is not such path, return -1. In an undirected graph, there are many ways to visualize a graph. For example, there is a graph has 10 nodes, and 12 edges, shown in the picture. It can ba organized to,çœ‹è¿™é”€é­‚çš„èµ°ä½(à¸‡â€¢Ì€-â€¢Ì)à¸‡il suffit de prendre un noeudâ€¦ã“ã‚“ãªã“ã¨ã‚‚ã€œThere is always a way to put some node in the same level from a start node as shown in the 2nd and third pictures. The only thing needs to be considered is how many levels or steps it takes until the target appears in the queue, then it is the final step to reach the target.Time comlexity is O(v + e) as same as regular reversal, and uses a set to avoid revisiting. And the space comlexity is the set that stores all visited node, which is O(v). 12345678910111213141516171819202122232425262728public int shortestPath(List&lt;GraphNode&gt; graph, GraphNode start, GraphNode target) &#123; if (graph == null) return -1; if (start == target) return 0; Queue&lt;GraphNode&gt; q = new LinkedList&lt;&gt;(); Ser&lt;GraphNode&gt; visited = new HashSet&lt;&gt;(); int step = 0; q.offer(start); visited.add(start); while (!q.isEmpty()) &#123; int size = q.size(); step += 1; for (int i = 0; i &lt; size; i++) &#123; GraphNode cur = q.poll(); for (GraphNode nei : cur.neighbors) &#123; if (nei == target) &#123; return step; &#125; if (!visited.contains(nei)) &#123; q.offer(nei); visited.add(nei); &#125; &#125; &#125; &#125; return -1;&#125; ShortestPath(bidirection)input: List of graph node, starting node, and target node. If given graph is not null, both start and end position are not null.output: Return the shortest path from the start to the target. If there is not such path, return -1. step plus one from each direction. In a regular traversal, the time comlexity is about the same as monodirection. And the space remains the same. It is beacuse, even though traversing from two direction â€œat the same timeâ€, the total number of node in the graph is given.However, if each node expends X states at a level, and there are N levels. Then the time complexity is going to be X^N. Coming from two directions will reduce level to N/2 for each direction. The the time comlexity becomes 2 * X^(N/2), which optimizes about squareroot of the complexity. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int shortestPath(List&lt;GraphNode&gt; graph, GraphNode start, GraphNode target) &#123; if (graph == null) return -1; if (start == target) return 0; Queue&lt;GraphNode&gt; qStart = new LinkedList&lt;&gt;(); Ser&lt;GraphNode&gt; visitedStart = new HashSet&lt;&gt;(); Queue&lt;GraphNode qTarget = new LinkedList&lt;&gt;(); Ser&lt;GraphNode&gt; visitedTarget = new HashSet&lt;&gt;(); int step = 0; qStart.offer(start); visitedStart.add(start); qTarget.offer(target); visitedTarget.add(target); while (!qStart.isEmpty() &amp;&amp; !q.target.isEmpty()) &#123; //from start int sizeStart = qStart.size(); step += 1; for (int i = 0; i &lt; sizeStart; i++) &#123; GraphNode cur = qStart.poll(); for (GraphNode nei : cur.neighbors) &#123; if (qTarget.contains(nei)) return step; if (!visitedStart.contains(nei)) &#123; qStart.offer(nei); visitedStart.add(nei); &#125; &#125; &#125; //from target int sizeTarget = qTarget.size(); step += 1; for (int i = 0; i &lt; sizeTarget; i++) &#123; GraphNode cur = qTarget.poll(); for (GraphNode nei : cur.neighbors) &#123; if (qStart.contains(nei)) return step; if (!visitedTarget.contains(nei)) &#123; qTarget.offer(nei); visitedTarget.add(nei); &#125; &#125; &#125; &#125; return -1;&#125; Onlything changed in bidirection traverse is adding a queue for the direction, and check whether current node expands a node in the queue of the other direction.&lt;!â€“ Word Ladderinput: â€“&gt;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2018%2F04%2F22%2FAndroid-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ç”Ÿæ´»ä¸æ­¢æœ‰çœ¼å‰çš„æž¸æž, è¿˜æœ‰ç”Ÿå‘æ°´å’Œä¿æ¸©æ¯.è¿™æ˜¯ä¸€ç¯‡ä¸­è‹±æŽºæ‚çš„å­¦ä¹ ç¬”è®°. MVC è®¾è®¡æ¨¡å¼view controller Model(data) é¡¹ç›®ç»“æž„ä¸»è¦éƒ¨åˆ† MainActivity: åº”ç”¨ç¨‹åºçš„å…¥å£, å½“æž„å»ºå’Œè¿è¡Œç¨‹åºæ˜¯, ç³»ç»Ÿä¼šå¯åŠ¨è¿™ä¸ª Activity çš„å®žä¾‹å¹¶ä¸”åŠ è½½å¸ƒå±€(å¯ä»¥ç†è§£ä¸ºæž„é€ å‡½æ•°å§â€¦). Activity_main.xml: å¯¹äºŽæ¯ä¸€ä¸ªç”Ÿæˆçš„ activity æ¨¡å—, Android Studio éƒ½ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ª xml æ–‡ä»¶, ç”¨æ¥å®šä¹‰è¿™ä¸ª Activity çš„ç•Œé¢å¸ƒå±€( list view, grid view, color, font, etc.). manifests â€“&gt; AndroidManifest.xml: æ•´ä¸ªåº”ç”¨çš„å¸ƒå±€ä»¥åŠæ¯ä¸ªç»„ä»¶çš„å®šä¹‰, åŒ…æ‹¬äº† Activity, fragment ç­‰ç­‰. build.gradle: ä¸€ä¸ªæ˜¯ç”¨äºŽé¡¹ç›®çš„(app)é…ç½®, å¦ä¸€ä¸ªæ˜¯ç”¨æ¥åº”ç”¨æ¨¡å—çš„. drawable: ç»„ä»¶å…ƒç´ æ–‡ä»¶å¤¹. ç•Œé¢ç»“æž„ ViewGroup: å…¶å®žå°±æ˜¯ java çš„ä¸€ä¸ªç±», ç”¨æ¥æŽ§åˆ¶ä¸€ä¸ªç•Œé¢å†…çš„è§†å›¾å¸ƒå±€. View: ä»Žæºç å¯ä»¥çœ‹å‡º, Viewå®žé™…ä¸Šå®žçŽ°äº†ä¸€äº›ç•Œé¢ç»„ä»¶çš„æŽ¥å£. 12public class View extends Object implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource Activityåº”ç”¨ç¨‹åºçš„ä¸€ä¸ªç»„ä»¶.å‡ ä¹Žæ‰€æœ‰çš„ Activity éƒ½ä¼šåˆ›å»ºä¸€ä¸ªå¯ä»¥å’Œç”¨æˆ·è¿›è¡Œäº¤äº’çš„ç•Œé¢. åƒä¹‹å‰æåˆ°çš„, MainActivity æ˜¯åº”ç”¨ç¨‹åºçš„å…¥å£, å½“ç”¨æˆ·å¯åŠ¨è¿™ä¸ªç¨‹åºçš„æ—¶å€™, è¿™ä¸ªç»„ä»¶ä¼šç”Ÿæˆä¸€ä¸ªä¸»ç•Œé¢, ä¾‹å¦‚, ç™»é™†ç•Œé¢ç­‰ç­‰. ä¸€ä¸ªç¨‹åºå¯ä»¥æ‹¥æœ‰å¤šä¸ª Activity, è€Œä»–ä»¬ä¹‹é—´å¯ä»¥ç›¸äº’è°ƒç”¨. è°ƒç”¨çš„è¿‡ç¨‹å’Œæ™®é€šç¨‹åºçš„ call stack å·®ä¸å¤š. ä¾‹å¦‚, å½“ MainActivity è°ƒç”¨äº†å…¶ä»– Activity çš„ä¹‹åŽ, MainActivity ä¼šåœæ­¢, ä½†æ˜¯ä»ç„¶åœ¨ stack ä¸­. å½“è¢«è°ƒç”¨çš„ Activity è¿”å›žçš„æ—¶å€™, æ ˆé¡¶å…ƒç´ è¢«å¼¹å‡ºå¹¶é”€æ¯, ä¹‹å‰çš„æ ˆå†…å…ƒç´ ä¼šè¢«æ¢å¤. è¦ç¡®ä¿â€åœæ­¢â€, â€œç”Ÿæˆç•Œé¢â€, â€œæ¢å¤â€, â€œé”€æ¯â€ç­‰åŠŸèƒ½, å°±éœ€è¦åœ¨åˆ›å»º Activity çš„æ—¶å€™å®žçŽ°è¿™äº›æ–¹æ³•. å› ä¸ºå’Œæ‰€æœ‰å…¶ä»–ç»„ä»¶ä¸€æ ·, Activity ä¹Ÿæ˜¯ Java ä¸­çš„ä¸€ä¸ªç±». å…¶ä¸­2ä¸ªæ–¹æ³•æ˜¯å¿…é¡»è¦å®žçŽ°çš„, ç”Ÿæˆç•Œé¢(ä¸Žç”¨æˆ·äº¤äº’), å’Œåœæ­¢(æš‚åœä½†æ˜¯ä¸é”€æ¯). onCreate() ç›¸å½“äºŽæž„é€ å‡½æ•°, è°ƒç”¨å½“å‰ Activity çš„æ—¶å€™è°ƒç”¨è¿™ä¸ªæ–¹æ³•, å¹¶ä¸”è°ƒç”¨ setContentView() æ¥åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢. onPause() è¢«è°ƒç”¨çš„æ–°çš„ Activity è¦†ç›–äº†ä¹‹å‰çš„ Activity(ä¸å¯è§), é‚£ä¸ª Activity å­˜åœ¨æ ˆä¸­, å¤„äºŽåœæ­¢çŠ¶æ€, ä½†æ˜¯æ²¡æœ‰è¢«é”€æ¯. å…¶ä»–çš„æ–¹æ³•ä¾‹å¦‚, startActivity() , é€šè¿‡è°ƒç”¨ Intent ç±»åž‹çš„å¯¹è±¡æ¥å‘å…¶ä»– Activity ä¼ é€’æ¶ˆæ¯. startActivityForResult(), éœ€è¦ä»Ž Activity è¿”å›žæŸäº›æ•°æ®/ç»“æžœ. ç»“æžœä»ç„¶é€šè¿‡ intent ä¼ é€’. finish() ç»“æŸå½“å‰ Activity finishActivity() ç»“æŸä¹‹å‰çš„æŸä¸€ä¸ª Activity. Activity çš„ç”Ÿå‘½å‘¨æœŸ Intentç»„ä»¶ä¹‹é—´çš„é€šè®¯, åŒ…æ‹¬å¯åŠ¨ Activity, å¯åŠ¨ service, ä¼ é€’ broadcast. ä»Ž Activity çš„æ–¹æ³•å®žçŽ°ä¸Šå¯ä»¥çœ‹å‡ºæ¥, Intent è¿™ä¸ªç±»åž‹çš„å¯¹è±¡å¯ä»¥æºå¸¦æ•°æ®.Intentæ˜¯ä¸¤ä¸ªactivityä¹‹é—´çš„ä¿¡ä½¿ï¼Œè®©ä¸€ä¸ªactivityä¼ é€’æ¶ˆæ¯/å‘½ä»¤ç»™å¦ä¸€ä¸ªactivityï¼Œæœ€å¸¸ç”¨çš„å°±æ˜¯è®©ä¸€ä¸ªappé‡Œçš„activityå’Œå¦ä¸€ä¸ªappé‡Œçš„activityè¿›è¡Œäº¤æµã€‚ Intentæœ‰ä¸‰ä¸ªç”¨é€”ï¼š start an activity (ä¼šä½¿ç”¨UIï¼‰ start a service ï¼ˆåŽç«¯è¿è¡Œï¼Œä¸ä½¿ç”¨UIï¼‰1 deliver a broadcast to other apps åœ¨1ï¼Œ2ç§ç”¨é€”ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ï¼š explicit intentï¼Œ intentåœ¨åˆå§‹åŒ–æ—¶å°±è§„å®šå¥½äº†å‘é€æ–¹å’ŒæŽ¥æ”¶æ–¹e.g. Intent intent = new Intent(this, Hello.class); å‘é€æ–¹æ˜¯thisï¼Œä¹Ÿå°±æ˜¯å½“å‰activityï¼ŒæŽ¥æ”¶æ–¹æ˜¯ä¸€ä¸ªå«Helloçš„activity implicit intentï¼Œintentåœ¨åˆå§‹åŒ–æ—¶æ²¡æœ‰è§„å®šå¥½å‘é€æ–¹å’ŒæŽ¥æ”¶æ–¹ï¼Œä½†å£°æ˜Žéœ€æ±‚ã€‚Androidç³»ç»Ÿä¸­çš„activitymanagerï¼Œä¼šæ£€æŸ¥å…¶ä»–æ‰€æœ‰appå£°æ˜Žæ–‡ä»¶ä¸­çš„intent filterï¼Œæ‰¾å‡ºå¯ä»¥æ»¡è¶³éœ€æ±‚çš„activityï¼Œå¦‚æžœæœ‰å¤šä¸ªæ»¡è¶³æ¡ä»¶ï¼Œå°±å¼¹å‡ºåˆ—è¡¨ä¾›ç”¨æˆ·é€‰æ‹©ã€‚ ä½†æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œä¸ç®¡æ˜¯å“ªç§intentï¼Œéƒ½åªèƒ½æ‰§è¡Œâ€œæ‰“å¼€å¦ä¸€ä¸ªactivity/serviceâ€œçš„èƒ½åŠ›ï¼Œæ˜¯å› ä¸ºæŽ¥å—æ–¹åªæœ‰åœ¨onCreat()è¿™ä¸€æ­¥çš„æ—¶å€™ï¼Œæ‰èƒ½æŽ¥å—intentï¼Œä»Žè€Œstartã€‚ è€Œbroadcastä¸åŒï¼Œå®ƒå¯ä»¥åœ¨activityçš„ä»»ä½•ä¸€æ­¥è¿›å…¥ç›‘å¬çŠ¶æ€ï¼Œå®ƒå¯ä»¥è®©activityåšå„ç§äº‹æƒ…ï¼Œè€Œä¸å±€é™äºŽstartã€‚å¦å¤–ï¼Œå®ƒå¯ä»¥ä¸€å¯¹å¤šï¼ŒåŒæ—¶è®©å¤šä¸ªactivityå“åº”ï¼ˆå“åº”çš„å®žçŽ°æ–¹å¼ä¸ºextends BroadcastReceiver, ä»¥åŠåœ¨life cycle functionä¸­å†™å…¥ç›‘å¬å¼€å§‹ï¼ˆregisterï¼‰ï¼‰ã€‚ æ€»ç»“ï¼šæ™®é€šintentåªèƒ½ä¸€å¯¹ä¸€ï¼Œå¹¶åªèƒ½æ‰§è¡Œstartæ“ä½œè®©activity/serviceå¯åŠ¨broadcastå¯ä»¥ä¸€å¯¹å¤šï¼Œå¹¶èƒ½è®©activityåšå„ç§äº‹æƒ…ã€‚è€Œä¸”broadcastæœ‰åˆ†çº§åˆ«ï¼Œç³»ç»Ÿçº§åˆ«çš„æŸäº›broadcastç¦æ­¢æ™®é€šappè¿›è¡Œç›‘å¬ã€‚2 Fragment3.0ç‰ˆæœ¬ä¸­å¼•å…¥, ä¸ºäº†åº”ç”¨åœ¨å¤§å±å¹•è®¾å¤‡ä¸Š. Fragment ä¾èµ–äºŽ Activity å­˜åœ¨, ä½†æ˜¯æ‹¥æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ, æ‹¥æœ‰ç‹¬ç«‹çš„è¾“å…¥äº‹ä»¶çš„å“åº”. ä¸€ä¸ª Activity å¯ä»¥åŒ…å«å¤šä¸ª Fragment, åŒä¸€ä¸ª fragment ä¹Ÿå¯ä»¥è¢«ä¸åŒçš„ activity è°ƒç”¨. å°¤å…¶é€‚ç”¨äºŽ Single Activity åº”ç”¨. å¯ä»¥æŠŠ Fragment çœ‹åšæ˜¯å¯ä»¥è¢«é‡å¤ä½¿ç”¨çš„æ¨¡å—. å¯ä»¥åšä¸º activity çš„ä¸€éƒ¨åˆ†, å¤šä¸ª fragment å‡ºçŽ°åœ¨åŒä¸€ä¸ª activity é‡Œé¢, æˆ–è€…ä¸€ä¸ª fragment åœ¨ä¸åŒçš„ activity å‡ºçŽ°. å¤„äºŽåŒä¸€ä¸ª Activity ä¸‹é¢çš„å¤šä¸ª Fragment å¯ä»¥é€šè¿‡ Activity è¿›è¡Œé€šè®¯, è€Œ Activity ä¹‹é—´éœ€è¦ intent æˆ–è€… broadcast æ¥è¿›è¡Œé€šè®¯. Activity è¿è¡Œä¸­å¯ä»¥æ·»åŠ , åˆ é™¤æˆ–è€…æ›¿æ¢ fragment. Fragment æ‹¥æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ, ä¼šå—åˆ°æ‰€ä¾é™„çš„ Activity çš„ç”Ÿå‘½å‘¨æœŸçš„å½±å“. ä½†æ˜¯ Activity ä¸ä¼šå—åˆ° Fragment çš„å½±å“. Fragment ç»§æ‰¿è‡ª Object, æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ç±», è€Œä¸æ˜¯ Activity çš„å­ç±». Activity æ˜¯ Context çš„å­ç±». å’Œ Activity ä¸€æ ·, åŠ è½½æ—¶éƒ½éœ€è¦è°ƒç”¨ä¸€ä¸ªç”Ÿæˆç•Œé¢çš„æ–¹æ³•, Oncreate() OnCreateView() å¦‚æžœä¸æƒ³è¿”å›ž UI ç•Œé¢, å¯ä»¥è¿”å›ž null. OnDestroyView() OnDestroy() å¯ä»¥åŠ¨æ€å’Œé™æ€åŠ è½½ä¸€ä¸ª Fragment: æ·»åŠ  layout æ–‡ä»¶ ä½¿ç”¨ add(), remove(), replace() ç­‰æ–¹æ³•åŠ¨æ€çš„æ·»åŠ , åˆ é™¤, æˆ–è€…æ›¿æ¢ç­‰æ“ä½œ. å’Œ Activity ä¸€æ ·, Fragment ä¹Ÿæœ‰ä¸€ä¸ªstack, é™¤éžè¢«é”€æ¯, å¦åˆ™å¯ä»¥å›žé€€åˆ°ä¸Šä¸€ä¸ª fragment. Fragment é€šè®¯ä¸¤ä¸ª Fragment ä¸åº”è¯¥ç›´æŽ¥é€šè®¯å› ä¸ºä¼šäº§ç”Ÿ fragment ä¹‹é—´çš„ dependency. (ä¾‹å¦‚è°ƒç”¨å¦ä¸€ä¸ª fragment äº§ç”Ÿçš„ instance) å¯ä»¥ä½¿ç”¨è§‚å¯Ÿè€…æ¨¡å¼çš„è®¾è®¡æ¨¡å¼, åˆ©ç”¨polymorphismçš„ç‰¹æ€§æ¥è§£å†³è¿™ä¸ªé—®é¢˜. Fragment é‡Œé¢å®šä¹‰ä¸€ä¸ª interface. ä¸»å‡½æ•°ç»§æ‰¿è¿™ä¸ª Fragment.interface, å¹¶ä¸”override æŽ¥å£. onAttach()æ–¹æ³•ä¸­ä¼ è¿›æ¥çš„ context å°±æ˜¯æ‰€ä¾èµ–çš„ Activity (çš„source). æŠŠä¼ å…¥çš„ activity çš„ instance å¼ºåˆ¶è½¬æ¢æˆæŽ¥å£ç±»åž‹(Fragment.interface) context. ç„¶åŽå°±å¯ä»¥é€šè¿‡è¿™ä¸ª reference è°ƒç”¨ Activity ä¸­çš„å…¶ä»–å‡½æ•°, è¿›è€Œè°ƒç”¨å¦å¤–ä¸€ä¸ª Fragment. Layoutæ–‡ä»¶æ¯ä¸ªç»„ä»¶å¦‚ä½•æ˜¾ç¤ºçš„æ–‡ä»¶. : æ ¹æ®å­ view ä¹‹é—´çš„ä¾èµ–å…³ç³»è€ŒæŽ’åˆ—, æ¨ªå‘çºµå‘éƒ½ä¼šè¿›è¡Œä¸€æ¬¡æ¯”è¾ƒ. : åŒ…å«çš„æ‰€æœ‰å­ view éƒ½æ˜¯ä»Žä¸Šåˆ°ä¸‹é¡ºåºæŽ’åˆ—çš„. ç»„ä»¶android ä¸­çš„æ¯ä¸€ä¸ªç»„ä»¶éƒ½æ˜¯ view çš„ä¸€ä¸ªå­ç±». ç»„ä»¶æœ‰å®ƒè‡ªå·±çš„å±žæ€§, åŒ…æ‹¬ id, layout_width, å’Œ layout_height ç­‰ç­‰. å½“æˆ‘ä»¬ç”Ÿæˆäº†ä¸€ä¸ª layout æ–‡ä»¶, å¹¶ä¸”ä¸ºè¿™ä¸ªç»„ä»¶è®¾ç½®äº†ä¸€ä¸ª id, é‚£ä¹ˆ R æ–‡ä»¶ä¸­å°±è‡ªåŠ¨ä¸ºè¿™ä¸ªç»„å»ºç”Ÿæˆäº†ä¸€ä¸ª id, è€Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸ª id æ¥å¯¹ç»„ä»¶è¿›è¡Œæ“ä½œ. ListView: ç”Ÿæˆä¸€ä¸ª ListView çš„ç»„ä»¶ list_view.xml 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/view_id" &lt;!-- å’Œ java ç¨‹åºè”ç³»çš„æ¡¥æ¢ --&gt; android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; æ”¹å†™ MainActivityé‡Œé¢çš„ onCreate(), åœ¨ç¨‹åºè¢«å¯åŠ¨çš„æ—¶å€™ç›´æŽ¥è°ƒç”¨è¿™ä¸ª ListView ç”Ÿæˆçš„ç•Œé¢. 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //è¦åŠ è½½åˆ°å½“å‰ Activity ç•Œé¢çš„ layout æ–‡ä»¶ setContentView(R.layout.list_view); //ç”Ÿæˆä¸€ä¸ª ListView çš„å¯¹è±¡, ä»Žè½½å…¥åˆ°å½“å‰ Activity çš„ layout æ–‡ä»¶ä¸­, é€šè¿‡ id æ‰¾åˆ° ListView çš„æ–‡ä»¶, æ”¾åˆ°è¿™ä¸ªå¯¹è±¡å®¹å™¨é‡Œ ListView view = (ListView) findViewById(R.id.view_id); //æ–°å»ºä¸€ä¸ªé€‚é…å™¨, å¹¶ä¸”å…³è”æ•°æ®æº ArrayAdapter adapter = new ArrayAdapter&lt;&gt;( this, R.layout.ç›®æ ‡å¸ƒå±€æ–‡ä»¶, R.id.ç›®æ ‡å¸ƒå±€æ–‡ä»¶çš„ id, new String[]&#123;"1", "2", "3", "4", "5"&#125;); // å®¹å™¨å’Œä¸Žå®¹å™¨åŒ¹é…çš„æ•°æ®éƒ½å‡†å¤‡å¥½äº†ä¹‹åŽ, assign adapter to view thisIsView.setAdapter(arrayAdapter); &#125;&#125; Adapter: åœ¨ Java ä¸­, Adapter æ˜¯ä¸€ä¸ªinterface. ç”¨æ¥æŠŠå¤æ‚çš„æ•°æ®å¡«å……åœ¨ç•Œé¢ä¸Šå’Œç”¨æˆ·äº¤äº’. ç»§æ‰¿äº† Adapter çš„å…¶ä»– interface æœ‰ ListAdapterå’Œ SpinnerAdapter. ç»§æ‰¿äº†è¿™ä¸¤ä¸ª interface çš„ç±»æ˜¯ BaseAdapter(æŠ½è±¡ç±»). å®žé™…åº”ç”¨ä¸­ BaseAdapter æ˜¯æœ€å¸¸ç”¨çš„. è€Œç»§æ‰¿äº† BaseAdapter çš„å¸¸ç”¨çš„ç±»æœ‰, SimpleAdapter, ArrayAdapter. ArrayAdapterç”¨æ¥ç»‘å®šå•ä¸€ç±»åž‹æ•°æ®(ä¾‹å¦‚é›†åˆ, æ•°ç»„, åˆ—è¡¨). SimpleAdapter: ç”¨æ¥ç»‘å®šå¤æ‚ç±»åž‹çš„æ•°æ®, åªèƒ½æ˜¯ç‰¹å®šæ³›åž‹çš„é›†åˆ. åˆ›å»ºä¸€ä¸ª layout æ–‡ä»¶, list_of_items.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;ImageView android:id="@+id/image_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" /&gt; &lt;TextView android:id="@+id/text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="20sp" android:textColor="@color/colorPrimary"/&gt;&lt;/LinearLayout&gt; æ”¹å†™MainActivity é‡Œé¢çš„ onCreate() æ–¹æ³•, æ³¨é‡ŠæŽ‰ä¹‹å‰ç”¨ ArrayAdapter ç”Ÿæˆçš„listview, ä¾‹å¦‚, 12345678910111213/** * SimpleAdapter(context, * å½“å‰ ListView åŠ è½½çš„æ¯ä¸€ä¸ª item æ‰€å¯¹åº”çš„å¸ƒå±€æ–‡ä»¶, * data: (List&lt;? extends Map&lt;String, ?&gt;&gt; data), * source: å¸ƒå±€æ–‡ä»¶ id, * from: Map çš„ key * to: Map çš„ value */simpleAdapter = new SimpleAdapter(this, getData(dataList), R.layout.item_of_list, new String[]&#123;"image","text"&#125;, new int[]&#123;R.id.image_view, R.id.text_view&#125;);thisIsView.setAdapter(simpleAdapter); è‡ªå®šä¹‰ç±»æ›´åŠ å¸¸ç”¨çš„å½¢å¼æ˜¯è‡ªå®šä¹‰ä¸€ä¸ªAdapter çš„å­ç±». å¼‚æ­¥åŠ è½½PS: (cast) å‘ä¸‹è½¬æ¢. 1.service: å¯ä»¥ç†è§£ä¸ºæ²¡æœ‰ UI çš„ Activity. â†©2.æ„Ÿè°¢@å¤©æ”¾åŒå­¦ç²¾å‡†åˆ°ä½çš„æ€»ç»“. áƒ¦(Â´ï½¥á´—ï½¥`)ç¬”èŠ¯. â†©]]></content>
  </entry>
  <entry>
    <title><![CDATA[React å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2018%2F04%2F22%2FReact-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[React, a JavaScript library for building user interfaces.1 Features Declarative: å£°æ˜Žå¼è¯­æ³•. ç›´æŽ¥å®šä¹‰æŸä¸€éƒ¨åˆ†çš„ UI æ˜¯ä»€ä¹ˆ. Component-Based: æ¨¡æ‹Ÿ DOM, å‡å°‘ä¸Ž DOM çš„äº¤äº’. ç»„ä»¶æœ‰ç‹¬ç«‹çš„ scope. Flexible: ä¸Žå·²çŸ¥æ¡†æž¶å¯ä»¥å¾ˆå¥½çš„é…åˆ. å•å‘å“åº”å¼æ•°æ®, å‡å°‘é‡å¤ä»£ç . é€šè¿‡ React æž„å»ºç»„ä»¶, ä»Žè€Œé‡å¤ä½¿ç”¨ç»„ä»¶. ECMAScript6 Features let vs. var: ä¸åŒäºŽ var, let æ˜¯ block-scoped. const: ç›¸å½“äºŽ java ä¸­çš„ final. åªè¯»ä¸å¯æ”¹. Template String: æ–°çš„è¯­æ³•ç³–, ç”¨åå¼•å·æ¥å®šä¹‰ä¸€ä¸ª String, å¼•å·å†…çš„æ–‡å­—ç»“æž„ä¿æŒä¸å˜. Srting string ${String} ${String} Object literal: ä¸åŒäºŽES5, å¦‚æžœparameter list çš„åå­—å’Œ function æœ¬èº«çš„ key ç›¸åŒçš„è¯, å°±å¯ä»¥åªå†™ key. ä¾‹å¦‚, 123456789101112131415function getCar(make, model, price) &#123; return &#123; make: make, model: model, price: price, &#125;;&#125;function getCar2(make, model, price) &#123; return &#123; make, model, price, &#125;;&#125; å¦‚æžœ key å’Œå‚æ•°åå­—ä¸åŒçš„è¯, åˆ™æ‰”éœ€è¦ä¿æŒ key-value-pair. å¦å¤–ä¸€ä¸ªè¯­æ³•ç³–æ˜¯, å¯ä»¥ä½¿ç”¨ string template ç›´æŽ¥å¯¹ key è¿›è¡Œæ“ä½œ, ä¾‹å¦‚å¢žåŠ ä¸€ä¸ªå±žæ€§ madeBy(value of make), é‚£ä¹ˆå°±å¯ä»¥ç›´æŽ¥å†™æˆ [madeBy${make}] : value. é‚£ä¹ˆç”Ÿæˆçš„ key å°±æ˜¯è‡ªåŠ¨ä¼ å…¥makeæ‰€å¯¹åº”çš„ value. ä¾‹å¦‚,è¿™æ—¶å€™, è¿™ä¸ªå±žæ€§çš„åå­—å°±ä¼šå˜æˆmadeByBMW : value. 1const car = getCar4('BMW', 'X5', 60000) å‡½æ•°ä¸å†éœ€è¦æ˜Žç¡®çš„å†™å‡º function(){ }çš„æ ¼å¼, è€Œå¯ä»¥ç›´æŽ¥åœ¨å±žæ€§åŽé¢å†™ä¸Š(){ }, ä¾‹å¦‚, depreciate: function() { } &lt;===&gt; depreciate() { }. Arrow Function: (å‚æ•°) =&gt; { } ä¾‹å¦‚,2 12345678const arr = [1, 2, 3, 4];const double = arr.map(function(n) &#123; return n * 2;&#125;);const double1 = arr.map((n) =&gt; &#123; return n * 2&#125;); å®ƒä¼šè‡ªåŠ¨ç»‘å®š this, åœ¨å®ƒè¢«å®šä¹‰çš„é‚£ä¸ªthis. 3 å¯ä»¥åœ¨å‚æ•°é‡Œé¢ä¼ é»˜è®¤å€¼, ä¾‹å¦‚, 123function f(x, y=12) &#123; return x + y;&#125; å¯¹äºŽä¸Šé¢çš„ä¾‹å­, 1f(3) //15 å¯ä»¥ä¼ å…¥rest parameter, ç”¨â€¦æ¥è¡¨ç¤º, ä¾‹å¦‚, 12345function f(x, ...y) &#123; //å‰©ä½™çš„ parameter è¢«å­˜åˆ°ä¸€ä¸ª array é‡Œé¢, å¯ä»¥ç©¿å…¥ä»»æ„é•¿åº¦çš„å‚æ•°åœ¨ x åŽé¢. return x * y.length;&#125;f(3, "hello", true) //å‰©ä½™çš„ parameter æ˜¯é•¿åº¦ä¸º 2 çš„ array, æ‰€ä»¥ç»“æžœæ˜¯6. Spread Operator (â€¦), ä½¿ç”¨...æ¥åˆ†ç¦»ä¸€ä¸ªé›†åˆç±»åž‹, ç”¨æ¥ concatate å¤šä¸ªæ•°ç»„éžå¸¸çš„çµæ´». ä¾‹å¦‚, 1234567const arr = [1, 2, 3, 4];const arr1 = [5, 6, 7, 8];const arr2 = [...arr, 111, 222, ...arr1]; // [1, 2, 3, 4, 111, 222, 5, 6, 7, 8]const obj1 = &#123;a: 1, b: 2&#125;;const obj2 = &#123;...obj1, c: 3&#125;;console.log(obj2); // &#123;a: 1, b: 2, c: 3&#125; ä¹Ÿå¯ä»¥å½“åšå‚æ•°ä¼ å…¥, 1234const f = (x, y, z) =&gt; x + y + z;const arr = [1, 2, 3];console.log(f(...arr)); // 6console.log(f(...[1,2,3])) // 6 Destructuring ç”¨æ¥åšä¸€ä¸ªä¸€ä¸€å¯¹åº”çš„è¯»å†™æ“ä½œ. ä¾‹å¦‚, 123456789101112131415161718192021222324let a, b, rest;[a, , b] = [1,2,3];console.log(a); // 1console.log(b); // 3[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50]// object destructuringlet &#123; a, b &#125; = &#123; a: 10, b: 20 &#125;;console.log(a); // 10console.log(b); // 20let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;console.log(z) // &#123;a: 3, b: 4&#125;// Fail-soft destructuringvar [v] = [];console.log(v); // undefined// Fail-soft destructuring with defaultsvar [v = 1] = []; console.log(v); // 1; æ”¯æŒ class (æ”¯æŒ OOP çš„è¯­æ³•ç³–) 1234567891011121314class ClassName &#123; //æž„é€ å‡½æ•° constructor(name) &#123; this.name = name; &#125; //function method() &#123; console.log(this.name + 'say something.'); &#125; // é™æ€å‡½æ•° static method() &#123; console.log('do something'); &#125;&#125; å¯ä»¥ç»§æ‰¿ 12345678910class SubClass extends SuperClass &#123; constructor(name, age) &#123; super(name); this.age = age; &#125; //override speak() &#123; console.log(this.name + 'do something'); &#125;&#125; JSXJavaScript çš„è¯­æ³•æ‰©å±•, å…è®¸åœ¨ JavaScript é‡Œé¢ä½¿ç”¨ XML è¯­æ³•. ç”¨ç®€å•çš„è¯­æ³•ç”Ÿæˆ react å¯¹è±¡. ç”Ÿæˆ React å¯¹è±¡: å¯ä»¥é€šè¿‡ react è¿›è¡Œæ¸²æŸ“çš„å¯¹è±¡.ç›´ä½¿ç”¨tagå®šä¹‰. ä¾‹å¦‚,1const element = &lt;h1 id="greeting"&gt;Hello, world!&lt;/h1&gt;; ç”Ÿæˆäº†ä¸€ä¸ª react çš„å¯¹è±¡, å®ƒåŒ…å«äº†3ä¸ªå…ƒç´ , tag å, å±žæ€§, å’Œâ€Hello, Worldâ€, å®ƒç­‰ä»·äºŽ,12345const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); æ¸²æŸ“å¯¹è±¡1ReactDOM.render(element, document.getElementById(&apos;root&apos;)); æ¡ä»¶æ¸²æŸ“å’Œæ™®é€šçš„ JavaScript çš„ä½¿ç”¨æ–¹æ³•ä¸€æ ·, å¯ä»¥é€šè¿‡ if è¯­å¥æ¥æŽ§åˆ¶æ¸²æŸ“çš„ç»„ä»¶. ä¾‹å¦‚,123456789function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125;const element1 = getGreeting();ReactDOM.render(element1, document.getElementById('root')); æ›´æ–°æ¸²æŸ“è¿‡çš„ react å¯¹è±¡4å¯¹äºŽæ¸²æŸ“è¿‡çš„ç»„ä»¶, å¦‚æžœéœ€è¦æ›´æ–°, åˆ™ä¼šé‡æ–°æ¸²æŸ“éœ€è¦æ›´æ–°çš„ç»„ä»¶. ä¾‹å¦‚,12345678910111213function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById('root') );&#125;setInterval(tick, 1000); åœ¨è¿™ä¸ªä¾‹å­ä¸­, åªæœ‰&lt;h2&gt;è¢«rerenderäº†. è¿™é‡Œåº”ç”¨äº† VDOM çš„æ¦‚å¿µ. Virtual DOMVDOM æ˜¯ä¸€ç§ç¼–ç¨‹æ¦‚å¿µ. æ˜¯æŒ‡è™šæ‹Ÿçš„è§†å›¾è¢«ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œå¹¶é€šè¿‡è¯¸å¦‚ReactDOMè¿™æ ·çš„åº“ä¸Žâ€œçœŸå®žâ€çš„DOMä¿æŒåŒæ­¥ã€‚è¿™ä¸ªè¿‡ç¨‹è¢«ç§°ä¸ºå’Œè§£ã€‚è¿™ç§ç¼–ç¨‹æ–¹æ³•ä½¿ç”¨äº†Reactçš„å£°æ˜Žå¼APIï¼šä½ éœ€è¦å‘Šè¯‰Reactä½ æƒ³è®©è§†å›¾å¤„äºŽä»€ä¹ˆçŠ¶æ€ï¼ŒReactåˆ™è´Ÿè´£ç¡®ä¿DOMä¸Žè¯¥çŠ¶æ€ç›¸åŒ¹é…ã€‚å› æ­¤ä½ åœ¨æž„å»ºä½ çš„åº”ç”¨æ—¶ä¸å¿…è‡ªå·±åŽ»å®Œæˆå±žæ€§æ“ä½œã€äº‹ä»¶å¤„ç†ã€DOMæ›´æ–°ï¼ŒReactä¼šæ›¿ä½ å®Œæˆè¿™ä¸€åˆ‡5. åœ¨åˆ›å»ºä¸€ä¸ª react å¯¹è±¡çš„æ—¶å€™å¯ä»¥é€šè¿‡æäº¤ä¸€ä¸ªåŒ…å«äº†å¤šä¸ªç»„ä»¶çš„ tag æ¥åŒæ—¶åˆ›å»ºå¤šä¸ª react å¯¹è±¡. è€Œæäº¤çš„è¿™ä¸ª tag å°±ç›¸å½“äºŽä¸€ä¸ª root node. å½“æ ¹èŠ‚ç‚¹çš„ä»»æ„å­æ ‘å‘ç”Ÿå˜åŒ–çš„æ—¶å€™, react ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„ VDOM ä»Žè€ŒæŠŠæ–°çš„çŠ¶æ€æ˜ å°„åˆ°è¿™ä¸ª VDOM ä¸Šé¢. é€šè¿‡åœ¨åŽŸæœ‰çš„ VDOM å’Œæ–°çš„ VDOM ä¸Šé¢è¿è¡Œ diffing algorithm æ‰¾åˆ°ç›¸åº”çš„èŠ‚ç‚¹, å¯¹å…¶è¿›è¡Œé‡æ–°æ¸²æŸ“, åº”ç”¨åˆ°çœŸæ­£çš„ DOM ä¸Šé¢, è€Œä¸ä¼šå½±å“å…¶ä»–ç»„ä»¶. ä»Žè€Œå¤§å¤§å‡å°‘äº†å¯¹äºŽå®žé™… DOM çš„æ“ä½œ. Componentä½¿ç”¨ functionç›´æŽ¥é€šè¿‡ JavaScript å‡½æ•°æ¥ç”Ÿæˆä¸€ä¸ª react çš„ç»„ä»¶. ä¾‹å¦‚,12345function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;; &#125;ReactDOM.render(&lt;Welcom name="Evelyn"/&gt;, document.getElementById('root')); å‡½æ•°çš„å‚æ•°ä¼ é€’ä½¿ç”¨ props å…³é”®å­—. åœ¨ render çš„æ—¶å€™å¯ä»¥ä½¿ç”¨ JSX è¯­æ³•, åœ¨ç»„ä»¶åŽé¢æ·»åŠ å±žæ€§å³å¯. ä½¿ç”¨ class(ç±»)åˆ›å»ºä¸€ä¸ª React.Component çš„å­ç±», è¿”å›žçš„æ˜¯éœ€è¦æ¸²æŸ“çš„ç»„ä»¶. props é€šè¿‡ç›´æŽ¥è°ƒç”¨çš„æ–¹æ³•ä¼ é€’å‚æ•°. ä¾‹å¦‚,123456class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;ReactDOM.render(&lt;Welcom name="Evelyn"/&gt;, document.getElementById('root')); Composing Componentsç»„ä»¶ä¹‹é—´å¯ä»¥è°ƒç”¨, ä»Žè€Œå¯¹äºŽåŒä¸€ç§ UI æ•ˆæžœè¿›è¡Œä¸åŒçš„è°ƒç”¨. ä¾‹å¦‚,12345678910111213141516function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name="Sara" /&gt; &lt;Welcome name="John" /&gt; &lt;Welcome name="Richard" /&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); è¿™é‡Œé¢å®žé™…ä¸Šåº”ç”¨åˆ°äº† react é‡Œé¢çš„ mounting life cycle çš„æ¦‚å¿µ. åœ¨æ¸²æŸ“(render) App çš„è¿‡ç¨‹ä¸­, å‘çŽ°äº† Welcome ç»„ä»¶, å¯¹å…¶è¿›è¡Œä¼ é€’å‚æ•°ä»¥åŠæ¸²æŸ“, ç„¶åŽè¿”å›žçš„è¿™æ ·ä¸€ä¸ªè¿‡ç¨‹. ä»Žè€Œå®žçŽ°äº†é‡å¤ä½¿ç”¨å·²ç»å®šä¹‰å¥½äº†çš„ react çš„å¯¹è±¡. Propsåœ¨ç”Ÿæˆç»„ä»¶çš„è¿‡ç¨‹ä¸­, ä¸è®ºæ˜¯é€šè¿‡ function è¿˜æ˜¯ class çš„æ–¹å¼, éƒ½ä¸èƒ½å¯¹ä¼ å…¥çš„å‚æ•°è¿›è¡Œä¿®æ”¹. å¯ä»¥å¯¹å‚æ•°è¿›è¡Œä»»æ„æ“ä½œ, ä½†æ˜¯ä¸å¯ä»¥ä¿®æ”¹å‚æ•°. å¦‚æžœéœ€è¦å¯¹å‚æ•°è¿›è¡Œæ›´æ”¹, åˆ™éœ€è¦é€šè¿‡ setState(). Stateä¸Ž props ç›¸ç±»ä¼¼, state ä¹Ÿæ˜¯å±žäºŽç±»çš„ä¸€ä¸ªå±žæ€§. ä½†æ˜¯local state æ˜¯å±žäºŽç±»çš„, ç§æœ‰çš„çŠ¶æ€. 1.https://reactjs.org/ â†©2.map è¿”å›žä¸€ä¸ªæ–°çš„æ•°ç»„. â†©3.æ³¨æ„ this çš„ç”Ÿæˆæ–¹å¼å¹¶æ²¡æœ‰å‘ç”Ÿæ”¹å˜, this åªæœ‰åœ¨ç±»è¢«åˆå§‹åŒ–çš„æ—¶å€™æ‰ä¼šäº§ç”Ÿ(è°ƒç”¨è¿™ä¸ªç±»çš„æ–¹æ³•). â†©4.react çš„å¯¹è±¡æ˜¯ immutable çš„. ä¸€æ—¦ç”Ÿæˆæ— æ³•æ›´æ”¹. â†©5.https://doc.react-china.org/docs â†©]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æµ…è°ˆå•ä¾‹æ¨¡å¼ - Singleton Pattern]]></title>
    <url>%2F2018%2F04%2F20%2F%E6%B5%85%E8%B0%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[æˆ‘è®¤ä¸º, å•ä¾‹æ¨¡å¼å¯ä»¥ç®€å•ç†è§£ä¸ºâ€åªç”Ÿä¸€ä¸ªå¥½â€çš„è®¡åˆ’ç”Ÿè‚²è®¾è®¡æ¨¡å¼.æˆ–è€… instance çš„éž 0 å³ 1 çš„çŠ¶æ€ â€“â€“â€“ è¦ä¹ˆæ²¡æœ‰, æœ‰å°±åªæœ‰ä¸€ä¸ª. å…¶å®žé€»è¾‘å¾ˆç®€å•, ç”±ç±»è‡ªå·±å†³å®šä»€ä¹ˆæ—¶å€™è¦ç”Ÿæˆä¸€ä¸ª instance, ä»¥åŠç¡®è®¤æ˜¯å¦å·²ç»ç”Ÿæˆäº†ä¸€ä¸ªå®žä¾‹.æä¾›ä¸€ä¸ªå…¨å±€çš„è®¿é—®ç‚¹(è°ƒç”¨æž„é€ å‡½æ•°çš„æ–¹æ³•). å¤–éƒ¨ä¸èƒ½å¤Ÿè°ƒç”¨æž„é€ å‡½æ•° â€“â€“&gt; æž„é€ å‡½æ•°ç§æœ‰åŒ–( private) ç”±å†…éƒ¨ç”Ÿæˆä¸€ä¸ªinstance â€“â€“&gt; å®žçŽ°ä¸€ä¸ªå¯ä»¥è°ƒç”¨æž„é€ å‡½æ•°çš„æ–¹æ³•. ç±»éœ€è¦ç¡®è®¤æ˜¯å¦å·²ç»ç”Ÿæˆäº†ä¸€ä¸ªinstance â€“â€“&gt; instance == null ? create : instance; è¿™å‡ ä¸ªé€»è¾‘å°±å¯ä»¥å®žçŽ°ä¸€ä¸ªç®€(qi)å•(gai)ç‰ˆçš„å•ä¾‹æ¨¡å¼çš„ç±»äº†. ä»£ç å¦‚ä¸‹, 123456789101112131415public class Singleton &#123; private static Singleton instance; //private constructor private Singleton() &#123;/*initialization*/&#125; //static method for creating and visiting instance from outside public static Singleton getInstance() &#123; //whether instance exists if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; ç„¶é¹…ä¸Šé¢çš„ä¾‹å­ä¸èƒ½å¤Ÿè§£å†³çº¿ç¨‹å®‰å…¨é—®é¢˜, åœ¨å¤šçº¿ç¨‹çš„çŽ¯å¢ƒå†…, å‡è®¾çº¿ç¨‹ A å’Œçº¿ç¨‹ B åŒæ—¶è®¿é—®è¿™ä¸ªç±», å½“çº¿ç¨‹ A è®¿é—®çš„æ—¶å€™å®žä¾‹è¿˜æ²¡æœ‰è¢«åˆ›å»º, è€Œå½“çº¿ç¨‹ B è®¿é—®çš„æ—¶å€™ A å·²ç»è®¿é—®è¿‡äº†, ä½†æ˜¯å®žä¾‹å¹¶æ²¡æœ‰è¢«åˆ›å»º, æ‰€ä»¥ B è®¿é—®çš„æ—¶å€™ instance ä»ç„¶æ˜¯ null, é‚£ä¹ˆå°±ä¼šå‡ºçŽ°instance é‡å¤åˆ›å»ºçš„é—®é¢˜. è§£å†³çš„æ–¹æ³•ä¹Ÿæ˜¯ç®€å•ç²—æš´ â€“â€“â€“ ç›´æŽ¥åŠ é”, ä»£ç å¦‚ä¸‹, 123456789101112public class Singleton &#123; private static Singleton instance; private Singleton()&#123;/*initialization*/&#125; public synchronized static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; ç„¶é¹…, è¿™ç§æ–¹æ³•ä¹Ÿæœ‰å®ƒçš„é—®é¢˜, å®ƒå¹¶ä¸é«˜æ•ˆ. å› ä¸ºåªæœ‰åœ¨åˆ›å»ºçš„æ—¶å€™æ‰éœ€è¦ mutual exclusion æ¥ç¡®ä¿ä¸ä¼šäº§ç”Ÿå¤šä¸ªå®žä¾‹. å¼€é”è§£é”çš„è¿‡ç¨‹å®žåœ¨éº»çƒ¦. äºŽæ˜¯, åŒé‡é”å®šå‡ºçŽ°äº†. 1234567891011121314public class Singleton &#123; private static Singleton instance; private Singleton()&#123;/*initialization*/&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; è€Œè¿™ä¸ªç‰ˆæœ¬çš„åŒé‡é”å®šä¾ç„¶ä¼šäº§ç”Ÿé—®é¢˜, åŽŸç†å…¶å®žå’Œç¬¬ä¸€ä¸ªå·®ä¸å¤š, å¦‚æžœ A åœ¨åˆ›å»ºçš„è¿‡ç¨‹ä¸­è¢« B çœ‹åˆ°äº†, é‚£ä¹ˆ B ä¼šè®¤ä¸ºinstance å·²ç»è¢« A åˆ›å»ºå¥½äº†(å¯æ˜¯æœ‰å¯èƒ½å¹¶æ²¡æœ‰å®Œæˆåˆå§‹åŒ–, åªæ˜¯è¢«åˆ†é…äº†å†…å­˜), é‚£ä¹ˆç›´æŽ¥è°ƒç”¨è¿™ä¸ªå®žä¾‹, ä¼šå¯¼è‡´ç¨‹åºå´©æºƒ. ä¿®æ”¹çš„æ–¹æ³•ä¾ç„¶å¾ˆç®€å• (ç®€å•çš„ä¸œè¥¿å¤šåŠå‘å¤šâ€¦.). ä½¿ç”¨ volatile å…³é”®å­—. ä»£ç å¦‚ä¸‹, 1234567891011121314public class Singleton &#123; private volatile static Singleton instance; private Singleton()&#123;/*initialization*/&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; è¿™æ ·å°±èƒ½å¤Ÿç¡®ä¿æ¯ä¸€ä¸ªè¯»å’Œå†™çš„ç¡®å®šæ€§äº†, å› ä¸º volatile ç¡®ä¿äº†å®ƒæ‰€æŒ‡å‘çš„å˜é‡çš„è¯»æ“ä½œä¸€å®šå‘ç”Ÿåœ¨å†™æ“ä½œçš„åŽé¢(writing precedes reading). è¿™æ ·æˆ‘ä»¬å°±ä¸ç”¨è®©çº¿ç¨‹æ¯æ¬¡éƒ½æž·é”, è€Œæ˜¯åªæœ‰åœ¨å®žä¾‹æœªè¢«åˆ›å»ºçš„æ—¶å€™æ‰åšåŠ é”å¤„ç†, å¹¶ä¸”ç¡®ä¿å®žä¾‹çš„ç¡®å®šæ€§. å¦ä¸€ç§ç¡®ä¿çº¿ç¨‹å®‰å…¨çš„æ–¹æ³•æ˜¯, ä½¿ç”¨é™æ€åˆå§‹åŒ–(static final). ä¸€åŠ è½½å°±åˆå§‹åŒ–. è¿™æ ·å°±ä¸éœ€è¦å†è€ƒè™‘å…¶ä»–é—®é¢˜, ç›´æŽ¥æ‹¿æ¥ç”¨å°±å¯ä»¥äº†. ä»£ç å¦‚ä¸‹, 12345678910public class Singleton &#123; private static final Singleton instance = new Singleton(); private Singleton()&#123;/*initialization*/&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; è€Œè¿™ç§æ–¹æ³•çš„ç¼ºé™·åœ¨äºŽ, æå‰å ç”¨èµ„æº. å¹¶ä¸”, å¦‚æžœåœ¨åˆå§‹åŒ–çš„æ—¶å€™éœ€è¦è®¾ç½®å‚æ•°, é‚£ä¹ˆè¿™ç§æ–¹æ³•æ— æ³•è¢«åº”ç”¨. å› ä¸º final åŸŸä¸€æ—¦åˆ›å»ºä¸èƒ½æ›´æ”¹.æœ€åŽä¹Ÿæ˜¯æœ€ç®€å•é«˜æ•ˆçš„æ–¹æ³•åº”è¯¥å°±æ˜¯æžšä¸¾äº†. This approach is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides and ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. â€¦ but a single-element enum type is often the best way to implement a singleton. [1] Enum ç¡®ä¿çº¿ç¨‹å®‰å…¨, ä¸éœ€è¦æ‹…å¿ƒé”çš„é—®é¢˜, å¹¶ä¸”èƒ½å¤Ÿé˜²æ­¢åºåˆ—åŒ–æˆ–è€…åå°„æœºåˆ¶å¯¼è‡´é‡æ–°åˆ›å»ºæ–°çš„å¯¹è±¡.ä»£ç ç®€æ´çš„è®©äººæ€€ç–‘äººç”Ÿâ€¦ 123public enum Singleton &#123; INSTANCE;&#125; [1]: Bloch, Joshua. Effective Java (3rd Edition): Joshua Bloch: 9780134685991 â€¦ www.bing.com/cr?IG=5B8E21E3EB364911A45C4D01A0F4314B&amp;CID=066CBDC1AC5B61F50EE1B616ADF46080&amp;rd=1&amp;h=v1tkqRWZ4_Dmqdw9V5prH4iBztvXb3p4O5mt9M6yErY&amp;v=1&amp;r=https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997&amp;p=DevEx.LB.1,5081.1.]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ä»Ž char åˆ° String]]></title>
    <url>%2F2018%2F04%2F13%2FJava%E4%BB%8E%20char%20%E5%88%B0%20String%2F</url>
    <content type="text"><![CDATA[Java ä¸­çš„åŸºæœ¬æ•°æ®ç±»åž‹éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„wrapper class, æ‰€æœ‰çš„ wrapper class éƒ½æ˜¯ IMMUTABLE çš„. wrapper class çš„ä½œç”¨æ˜¯ä»€ä¹ˆå‘¢? å¯ä»¥è¢«åº”ç”¨åˆ° Java generic ä¸­, ä¾‹å¦‚ Listä¸­çš„ object åªèƒ½æ˜¯ wrapper class. å¯ä»¥å®šä¹‰/å¢žåŠ æˆå‘˜å‡½æ•°. å¯ä»¥è¡¨ç¤º null. charä¹Ÿæœ‰å®ƒå¯¹åº”çš„ wrapper class â€“&gt; Character Charåœ¨ Java ä¸­, char æ˜¯ primitive ç±»åž‹, String åˆ™æ˜¯ä¸€ä¸ªç±».Java ä¸­, ä¸€ä¸ª char (primitive type) ä½¿ç”¨çš„æ˜¯ Unicode, æ‰€ä»¥æ˜¯16ä½çš„(2bytes). å‰ 128(0~127) ä¸ª å’Œ ascii ç æ˜¯é‡å¤çš„. å‰ 3 ä¸ªå’Œç¬¬ 128 ä¸ªæ˜¯ä¸å¯æ‰“å°çš„( debug æ—¶å€™è¦æ³¨æ„, å¯ä»¥æ‰“å° int.) â€˜0â€™ ~ â€˜9â€™, â€˜aâ€™ ~ â€˜zâ€™, â€˜Aâ€™ ~ â€˜Zâ€™æ˜¯è¿žç»­æŽ’åˆ—çš„. æ‰€ä»¥å¯ä»¥é€šè¿‡+/-æ“ä½œæ¥å¾—åˆ°ä»–ä»¬çš„å€¼, æˆ–è€…åœ¨ä½ç½®. char å¸¸ç”¨çš„æ“ä½œ: char - â€˜0â€™ char â€“&gt; int char - â€˜aâ€™ char â€“&gt; int(position afterâ€™aâ€™ in the unicode chart) char - â€˜Aâ€™ char â€“&gt; int(position afterâ€™Aâ€™ in the unicode chart) cahr - â€˜aâ€™ + â€˜Aâ€™ lower â€“&gt; upper cahr - â€˜Aâ€™ + â€˜aâ€™ upper â€“&gt; lower (int)char char â€“&gt; unicode (char)int int(unicode) â€“&gt; char Stringæ¯ä¸€ä¸ª string çš„ç±»é‡Œé¢éƒ½æœ‰ä¸€ä¸ª final char[] value, int offset, å’Œ int count.offset ä½œä¸ºä¸€ä¸ªä¼˜åŒ–çš„å­˜åœ¨, å¤šæ•°åº”ç”¨äºŽå¾—åˆ°ä¸€ä¸ªStringçš„ substring (ä»Žä¸‹æ ‡ä¸º index çš„å…ƒç´ å‡ºå‘, æ•° count ä¸ªå…ƒç´ ). String çš„æž„é€ å‡½æ•°: String() String(â€œvalueâ€) String(char[] array) String(char[] array, int offset, int count) String(StringBuilder) å½“æ¶‰åŠåˆ°ä¸€ä¸ª string çš„é•¿åº¦å˜åŒ–çš„æ—¶å€™å¤šæ•°å»ºè®®ç”¨ StringBuilder è€Œä¸æ˜¯ç”¨ Concatenation(ç›´æŽ¥åŠ ). å¯¹äºŽ n ä¸ªé•¿åº¦ä¸º m çš„æ•°ç»„æ¥è¯´, concatenate çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2 m). å› ä¸ºm + m â€“&gt; 2m + m â€“&gt; 3m + m â€¦.â€“&gt; nm + m = (1 + 2 + 3â€¦.+ n) m = n^2 m (æ¯ä¸€æ¬¡ç›¸åŠ çš„æ—¶å€™éƒ½ä¼šæ–°å»ºä¸€ä¸ªå¯¹è±¡).è€Œ StringBuilder å†…éƒ¨å®žçŽ°æ˜¯ä¸€ä¸ªé•¿åº¦åŠ¨æ€å˜åŒ–çš„ char[]. Amortized time complexity æ˜¯ O(1)çš„, æ‰€ä»¥ n ä¸ª é•¿åº¦ä¸º m çš„æ•°ç»„ç›¸åŠ å°±æ˜¯ O(nm).* substring çš„ api: str.substring(start, end) //åŒ…å« start ä¸åŒ…å« end str.substring(start) //ä»Ž start åˆ°æœ€åŽ ç›¸è¾ƒäºŽ Java 7u6 æ¥è¯´, æ–°çš„ç‰ˆæœ¬ç›´æŽ¥åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„substring çš„å¯¹è±¡, ä¸é‡å¤ä½¿ç”¨åŽŸæ¥çš„ string, æ—¶é—´ä¸Šæ›´å¿«ä¸€äº›. è€Œ7u6ä¹‹å‰çš„ç‰ˆæœ¬åˆ›å»ºç©ºé—´ä¸Šé‡å¤ä½¿ç”¨äº†åŽŸæ¥çš„ string, åˆ›å»ºæ—¶é—´æ›´å¿«ä¸€äº›, ä½†æ˜¯ä½¿ç”¨èµ·æ¥çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n). å› ä¸º reference æŒ‡å‘çš„æ˜¯åŽŸæ¥ string åœ°å€çš„èµ·å§‹ä½ç½®. å¸¸ç”¨çš„è½¬æ¢æˆ String çš„æ–¹æ³•: primitive type: value + &quot;&quot; wrapper class: String.valueOf(value) //é¿å… NPE String è½¬æ¢æˆå…¶ä»–ç±»åž‹(ä¾‹å¦‚ Integer): Integer.valueOf(value) Integer.parseInt(value) String å¸¸ç”¨çš„ä¸€äº›çš„æ¯”è¾ƒå’Œåˆ¤æ–­çš„ api: boolean endsWith(&quot;suffix&quot;) boolean startsWith(&quot;prefix&quot;) int compareTo(&quot;anotherString&quot;) //lexicographical order int compareToIgnoreCase(&quot;string&quot;) boolean equals(Object) boolean equalsIgnoreCase(&quot;string&quot;) ä¸€äº›å…¶ä»–çš„å¸¸ç”¨ api: boolean contains(â€œchar sequenceâ€) String[] split(â€œregexâ€) String[] split(â€œregexâ€, limitNumber) String trim() String toLowerCase() String toUpperCase() int indexOf(unicode#) //param ç±»åž‹æ˜¯ int, è¿™é‡Œé¢é€šå¸¸ç›´æŽ¥ä½¿ç”¨ä¸€ä¸ª char, åªæ˜¯è‡ªåŠ¨è¿›è¡Œäº†ä¸€ä¸ªç±»åž‹è½¬æ¢. int lastIndexOf(â€˜charâ€™)etc. StringBuilder çš„å¸¸ç”¨ api:2 append(â€˜charâ€™) //O(1) append(â€œStringâ€) //O(n) è¿™é‡Œé¢, è¿”å›žç±»åž‹æ˜¯ String çš„æ–¹æ³•éƒ½ä¸æ˜¯ inplace çš„æ“ä½œ, å› ä¸º String æ˜¯ immutable çš„ç±»åž‹. æ‰€ä»¥æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(n)çš„, å› ä¸ºè¦é‡æ–°åˆ›å»ºä¸€ä¸ªå¯¹è±¡1. Parse a String into Integer (ä¹žä¸ç‰ˆ atoi)input: A String with only positive numbers.output: The position integer, which the string represents. æœ€åŸºæœ¬çš„ char â€“&gt; int çš„åº”ç”¨. ä»£ç å¦‚ä¸‹: 1234567891011public int parsInt(String str) &#123; if (str == null || str.length() == 0) &#123; throw new IllegalArgumentException("Invalid input."); &#125; int result = 0; for (char ch : str.toCharArray()) &#123; result = result * 10 + (ch - '0'); &#125; return result;&#125; Atoiinput: A String with all characters that can make a valid integer.output: The integer. Corner cases: Null/Empty input Leading space Signs(+ / -) Overflow å…¶å®žå’Œå°±æ˜¯å¤šäº†ä¸€äº› corner case. å¯ä»¥å…ˆæŠŠåŸºç¡€ä»£ç å†™è¿›åŽ», ç„¶åŽé€æ¸æ·»åŠ è§£å†³æ–¹æ¡ˆ. ä»£ç å¦‚ä¸‹: 123456789101112131415161718192021222324252627282930public int parsInt(String str) &#123; if (str == null || str.length() == 0) &#123; throw new IllegalArgumentException("Invalid input."); //null/empty input &#125; str = str.trim(); //leading/trailing space boolean positive = true; //sign. int i = 0; while (i &lt; str.length()) &#123; if (str.charAt(i) == '-' || str.charAt(i) == '+') &#123; positive = str.charAt(i) == '+'; i++; //If it has a sign, whether it's '-' or '+', index needs to move rightward. &#125; &#125; //int result = 0; long result = 0; //overflow for (; i &lt; input.length; i++) &#123; result = result * 10 + (ch - '0'); if (result &gt; (long)Integer.MAX_VALUE + 1) &#123; //MAX_VALUE + 1 = abs(MIN_VALUE); break; &#125; &#125; result = positive ? result : result * -1; //adding sign if (result &gt; (long)Integer.MAX_VALUE) return Integer.MAX_VALUE; if (result &lt; (long)Integer.MIN_VALUE) return Integer.MIN_VALUE; return (int) result;&#125; Valid Numericinput: A string.output: Whether the string is a valid numeric. Corner cases: Null/empty input Leading/trailing space Leading 0s Decimal point Sign -/+ Scientific notation (e/E) 1234567891011121314public boolean isValid(String str) &#123; if (str == null || str.length() == 0) &#123; return false; &#125; String pattern = "[-+]?(([0-9]+(\.[0-9]*)?)|\.[0-9]+)([eE][-+]?[0-9]+)?" ; Pattern re = Pattern.compile(pattern); Matcher m = r.matcher(str); if (m.find())&#123; return true; &#125; return false;&#125; Char Removalinput: A string and target(s) that needs to be removed.output: A stirng after remove certain characters. å¯ä»¥ä½¿ç”¨ char array, ä¸¤ä¸ªæŒ‡é’ˆi, jä»Žå·¦å¾€å³æ‰«æ, içš„å·¦è¾¹ä¸åŒ…æ‹¬ i éƒ½æ˜¯è¦ä¿ç•™çš„, æœ€åŽè¿”å›ž new String(input, 0, i). æˆ–è€…ä½¿ç”¨ä¸€ä¸ª StringBuilder, ä¸€ä¸ªæŒ‡é’ˆ, å¦‚æžœæ˜¯éœ€è¦ä¿ç•™çš„å…ƒç´ å°±åŠ åˆ° StringBuilder é‡Œé¢, å¦åˆ™è·³è¿‡. éœ€è¦ä¸€ä¸ªé¢å¤–çš„æ•°æ®ç»“æž„ HashSet ä¸ºäº†å¯ä»¥å¿«é€Ÿçš„ç¡®è®¤æ˜¯å¦æ˜¯éœ€è¦è¢«åˆ é™¤çš„ target. ä»£ç å¦‚ä¸‹: 1234567891011121314151617181920public String removeChar(String str, List&lt;Character&gt; tagert) &#123; if (str == null || str.length == 0 || target.size() == 0) &#123; return str; &#125; Set&lt;Character&gt; candidates = new HashSet&lt;&gt;(); for (Character s : target) &#123; candidates.add(s); &#125; char[] set = str.toCharArray(); int i = j = 0; while (j &lt; set.length) &#123; if (!candidates.congtains(set[j])) &#123; set[i++] = set[j++]; &#125; else &#123; j++; &#125; &#125; return new String(set, 0, i);&#125; Space Removalinput: A string.output: A string with no leading nor trailing spaces, and leave one space between words. å’Œ char removal æ˜¯ä¸€æ ·çš„, åªæ˜¯ target å˜æˆäº† space. åˆ é™¤æ‰€æœ‰çš„ space ä¹‹åŽ, åœ¨ä¸åŒçš„å•è¯ä¸­é—´åŠ ä¸Šä¸€ä¸ªç©ºæ ¼. è¿™é‡Œåªéœ€è¦å…³æ³¨æŒ‡é’ˆ j çš„3ç§çŠ¶æ€, j == â€œ â€œ, j != â€œ â€œ (j æŒ‡å‘çš„æ˜¯å•è¯çš„é¦–å­—æ¯, j æŒ‡å‘çš„æ˜¯å•è¯çš„éžé¦–å­—æ¯). Cases: String with only spaces Leading spaces and trailing spaces ä»£ç å¦‚ä¸‹:123456789101112public String removeSpace(String str) &#123; if (str == null || str.length == 0) &#123; return str; &#125; char[] set = str.toCharArray(); int i = 0, j = 0; while (j &lt; set.length) &#123; if (j == " ") &#123; j++ &#125; &#125;&#125; Left Padinput: a string, output size, (and a char).output: new string with size of length fulfill by char/space. å®žçŽ°ä¸€ä¸ªleftpadåº“. åŒ…å«äº†ä¸¤ç§é‡è½½çš„æ–¹æ³•. æœ‰æ›¿è¡¥å­—ç¬¦. æ— æ›¿è¡¥å­—ç¬¦, åˆ™ç”¨ç©ºæ ¼ä»£æ›¿. è¿™æ˜¯ä¸€é“éšæœºæŠ½å‡ºæ¥çš„ç®€å•é¢˜, è¿˜æŒºå¥½çŽ©å„¿çš„. ç›´æŽ¥po ä¸€ä¸‹ä»£ç å§.æ—¶é—´å¤æ‚åº¦ O(n), n æ˜¯ size. ç©ºé—´æ˜¯ O(1).123456789101112131415161718192021222324252627public class LeftPad &#123; /** * @param originalStr: the string we want to append to with spaces * @param size: the target length of the string * @return: A string */ public String leftPad(String originalStr, int size) &#123; return leftPad(originalStr, size, ' '); &#125; /** * @param originalStr: the string we want to append to * @param size: the target length of the string * @param padChar: the character to pad to the left side of the string * @return: A string */ public String leftPad(String originalStr, int size, char padChar) &#123; if (originalStr == null) &#123; return null; &#125; StringBuilder bd = new StringBuilder(); for (int i = 0; i &lt; size - originalStr.length(); i++) &#123; bd.append(padChar); &#125; return new String(bd + originalStr); &#125;&#125; Palindrome Permutation I (LeetCode 266)input: a stringoutput: whehter there exists a palindrome permutation. æœ¬æ¥ä»¥ä¸ºæ˜¯ä¸€é“æŽ’åˆ—ç»„åˆé¢˜, ä½†æ˜¯è¦æ±‚è¿”å›žçš„æ˜¯ true or false. è”æƒ³ä¸€ä¸‹ palindrome çš„ç‰¹æ€§, ç›¸åŒçš„å­—æ¯æ•°é‡ä¸€å®šæ˜¯å¶æ•°çš„. å¯ä»¥æœ‰å”¯ä¸€ä¸€ä¸ªå•ç‹¬çš„å­˜åœ¨. é‚£ä¹ˆå…¶å®žå°±å¯ä»¥ç”¨æ‰“æ“‚å°çš„æ–¹å¼, ç”¨ä¸€ä¸ª set å°±å¯ä»¥äº†, åæ­£å‡ºçŽ°ä¸€ä¸ªç›¸åŒçš„å°±ä¼šåˆ é™¤ä¸€ä¸ª. æ—¶é—´å¤æ‚åº¦æ˜¯ O(n), ç©ºé—´å¤æ‚åº¦æ˜¯ O(n).123456789101112131415161718192021222324public class CanPermutePalindrome &#123; /** * @param s: the given string * @return: if a permutation of the string could form a palindrome */ public boolean canPermutePalindrome(String s) &#123; if (s == null) &#123; return true; &#125; //å­—æ¯å’Œå‡ºçŽ°çš„æ¬¡æ•° Set&lt;Character&gt; map = new HashSet&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (map.contains(ch)) &#123; map.remove(ch); &#125; else &#123; map.add(ch); &#125; &#125; return map.size() &gt; 1 ? false : true; &#125;&#125; Palindrome Permutation II (LeetCode 267)input: a string.output: return all possible palindrome permutations without duplicates. è™½ç„¶è¿™ä¸¤é“é¢˜æ˜¯å…„å¼Ÿå§, ä½†æ˜¯å·®è·æœ‰ç‚¹å¤§. éžè¦æ­ä¸Šç‚¹å„¿è”ç³»çš„è¯, palindrome permutation I å¯ä»¥çœ‹åšæ˜¯ä¸€ä¸ªé¢„å¤„ç†. é‚£ä¹ˆé¦–å…ˆè¦èŠ±è´¹ O(n)çš„æ—¶é—´æ¥åˆ¤æ–­ä¸€ä¸‹ç»™å®šçš„ string æ˜¯å¦èƒ½å¤Ÿæž„æˆ palindrome. å…¶æ¬¡å°±è¦O(n!)çš„æ—¶é—´æ·±æœæ‰¾æŽ’åˆ—äº†. ç¬¬ä¸€æ­¥çš„ç©ºé—´å¤æ‚åº¦æ˜¯ O(n), å› ä¸ºæœç´¢çš„è¿‡ç¨‹ä¸­å¯èƒ½ä¼šæŠŠå…¨éƒ¨å…ƒç´ éƒ½å­˜æ”¾åœ¨ set é‡Œé¢. ç¬¬äºŒæ­¥çš„ç©ºé—´å¤æ‚åº¦æ˜¯ O(n/2 + n/2),åªè€ƒè™‘ä¸€åŠå…ƒç´ çš„å…¨æŽ’åˆ—, æ‰€ä»¥è¿˜æ˜¯ O(n). æ ¹æ®å›žæ–‡çš„å®šä¹‰, ä¸­å¿ƒç‚¹å·¦å³ä¸¤è¾¹çš„å…ƒç´ æ˜¯å¯¹ç§°çš„, æ‰€ä»¥è¿™é‡Œéœ€è¦è€ƒè™‘ä¸¤ä¸ªå› ç´ , ä¸­å¿ƒå…ƒç´  å¯¹ç§°å…ƒç´ å¯ä»¥åƒ Left Pad é‚£é“é¢˜ä¸€æ ·, å¦‚æžœæœ‰ä¸­å¿ƒå…ƒç´ , åˆ™ä¼ å…¥ä¸­å¿ƒå…ƒç´ , å¦åˆ™ä¼ å…¥String (æ–¹ä¾¿ç›´æŽ¥åš concatenation). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class PalindromePermutationII &#123; /** * @param s: the given string * @return: all the palindromic permutations (without duplicates) of it */ public List&lt;String&gt; generatePalindromes(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (s == null) &#123; return result; &#125; //ç”¨æ¥åˆ¤æ–­æ˜¯å¦å¯ä»¥æˆä¸º palindrome, ä»¥åŠæœ€åŽå‰©ä½™çš„ä¸­å¿ƒå…ƒç´ æ˜¯ä»€ä¹ˆ Set&lt;Character&gt; map = new HashSet&lt;&gt;(); List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (map.contains(ch)) &#123; map.remove(ch); list.add(ch); &#125; else &#123; map.add(ch); &#125; &#125; if (map.size() &gt; 1) &#123; return result; &#125; String mid = ""; for (char c : map) &#123; mid = c + ""; &#125; //å¦‚æžœ input å·²ç»æŽ’å¥½åº, é‚£ä¹ˆå°±ä¸éœ€è¦æŽ’åºäº†. Collections.sort(list); helper(list, 0, new StringBuilder(), result, mid, new boolean[list.size()]); return result; &#125; private void helper(List&lt;Character&gt; list, int index, StringBuilder bd, List&lt;String&gt; result, String mid, boolean[] visited) &#123; if (bd.length() == list.size()) &#123; result.add(new String (bd + mid + bd.reverse().toString())); bd.reverse();/////////////è¿™é‡Œä¸€å®šè¦è®°å¾—ç¿»è½¬å›žæ¥, å¦åˆ™è¿”å›žä¸Šä¸€å±‚çš„ç»“æžœæ˜¯åè½¬è¿‡çš„ string return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; if (visited[i]) &#123; continue; &#125; if (i != 0 &amp;&amp; list.get(i) == list.get(i - 1) &amp;&amp; !visited[i - 1]) &#123; continue; &#125; bd.append(list.get(i)); visited[i] = true; helper(list, i + 1, bd, result, mid, visited); bd.deleteCharAt(bd.length() - 1); visited[i] = false; &#125; &#125;&#125; Java æœ‰ä¸€äº› cache/pooling ä¸Šçš„ä¼˜åŒ–(å°½é‡å‡å°‘åœ¨ heap ä¸Šåˆ›å»ºå¯¹è±¡), ä¾‹å¦‚ Integer object -128 ~ 127, ä¸¤ä¸ªç›¸åŒçš„ String ç­‰ç­‰1. æ‰€ä»¥åœ¨æ¯”è¾ƒä¸¤ä¸ª Object çš„å€¼æ˜¯å¦ç›¸ç­‰çš„æ—¶å€™, å°½é‡ä¸è¦ç”¨ ==, è€Œç”¨ .equals== å¦‚æžœä¸¤è¾¹éƒ½æ˜¯ reference, é‚£ä¹ˆ(æ²¡æœ‰ä¼˜åŒ–çš„æƒ…å†µä¸‹)ä¼šæ¯”è¾ƒåœ°å€. å¦‚æžœæœ‰ä¸€è¾¹æ˜¯ primitive type, é‚£ä¹ˆå°±ä¼šè¿›è¡Œ unboxing/autoboxing.è€Œ+ - * / &lt; &gt; &lt;= &gt;= åˆ™ä¸éœ€è¦æ‹…å¿ƒ, å› ä¸ºåœ¨ Java ä¸­å®ƒä»¬åªèƒ½å¤Ÿè¢«åº”ç”¨åœ¨ primitive type ä¸Šé¢, æ‰€ä»¥ä¼šè¢«è‡ªåŠ¨çš„ unboxing/autoboxing. 1.å¯¹äºŽ String æ¥è¯´, å› ä¸ºå®ƒæ˜¯ immutable çš„, å³ä½¿åšäº†ä¸€ä¸ªåœ¨ cache ä¸Šçš„ä¼˜åŒ–(ä¸¤ä¸ªå€¼ç›¸åŒçš„ varibale æŒ‡å‘äº†åŒä¸€ä¸ªåœ°å€), ä¹Ÿä¸ä¼šå½±å“ç»“æžœ. å› ä¸º String æ˜¯ immutable çš„, å¦‚æžœå¯¹å…¶ä¸­ä¸€ä¸ª varibale è¿›è¡Œäº†æ›´æ”¹(å¢žåˆ æ“ä½œ), é‚£ä¹ˆç³»ç»Ÿä¼šé‡æ–°åˆ›å»ºä¸€ä¸ªå¯¹è±¡å¹¶ä¸”ä½¿å˜é‡æŒ‡å‘è¿™ä¸ªæ–°çš„å¯¹è±¡çš„åœ°å€. â†©2.StringBuilder å’Œ StringBuffer æœ€ä¸»è¦çš„åŒºåˆ«å°±æ˜¯çº¿ç¨‹å®‰å…¨, å•çº¿ç¨‹ä¸­ä¸éœ€è¦ StringBuffer. â†©]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS ä»Žå…¥é—¨åˆ°æ”¾å¼ƒ IV]]></title>
    <url>%2F2018%2F04%2F13%2FDFS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%20IV%2F</url>
    <content type="text"><![CDATA[â€œæ™šä¸Šåƒå•¥?â€ â€œéšä¾¿.â€ â€œä¸è¡Œ.â€ â€œä¸ºå•¥?â€ â€œæ­»å¾ªçŽ¯äº†, æ²¡æœ‰é€€å‡ºæ¡ä»¶.â€]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS ä»Žå…¥é—¨åˆ°æ”¾å¼ƒ III]]></title>
    <url>%2F2018%2F04%2F10%2FDFS%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%20III%2F</url>
    <content type="text"><![CDATA[DFS çš„ç‰¹ç‚¹æ˜¯, ä»Žå“ªå„¿æ¥çš„çŠ¶æ€å›žåˆ°å“ªå„¿åŽ»(Back Tracking).DFS çš„æ€è·¯æ˜¯, æ‰§è¡Œå¤šå°‘å±‚, æ¯å±‚éƒ½æœ‰ä»€ä¹ˆçŠ¶æ€. ä¸Ž subset çš„ç±»åž‹ä¸å¤ªç›¸åŒçš„æ˜¯, subset é€šå¸¸ä»Žâ€ç©ºâ€å‡ºå‘, åœ¨æ¯ä¸€ä¸ªèŠ‚ç‚¹é€‰æ‹©æ˜¯å¦è¦é€‰æ‹©æŸä¸ªå…ƒç´ , ä»¥åŠæ˜¯å¦ç»§ç»­å‘ä¸‹(åŽ)æœç´¢.æŽ’åˆ—çš„é—®é¢˜æ¯ä¸€ä¸ªå…ƒç´ éƒ½è¦å‚ä¸Žåˆ°ç»“æžœå½“ä¸­, è€Œé¡ºåºå†³å®šç»“æžœ. å¯ä»¥ä»Žâ€ç©ºâ€å‡ºå‘, é‚£ä¹ˆåªæœ‰æœ€åŽä¸€å±‚çš„ç»“æžœæ˜¯æœ‰æ•ˆçš„; ä¹Ÿå¯ä»¥ä»Žâ€æ»¡â€å‡ºå‘, æ¯ä¸€ä¸ªä¸ç›¸åŒçš„æŽ’åˆ—é¡ºåºéƒ½æ˜¯æœ‰æ•ˆçš„. åŽŸç†éƒ½æ˜¯ç›¸åŒçš„ â€“â€“â€“ æ¯ä¸€ä¸ªå…ƒç´ éƒ½è¦å‡ºçŽ°åœ¨æ¯ä¸€ä¸ªä½ç½®ä¸Š. Permutationinput: A linear data structure like an array, a string, etc. No duplicated element.output: A list of lists of all permutations. å¯¹äºŽæ¯ä¸€ä¸ªå…ƒç´ æ¥è¯´, å®ƒè¦å°è¯•æ¯ä¸€ä¸ªä½ç½®. æˆ–è€…è¯´å¯¹äºŽæ¯ä¸€ä¸ªä½ç½®æ¥è¯´, å®ƒæœ‰ n ç§é€‰æ‹©. åœ¨ç¬¬ i å±‚çš„æ—¶å€™, æœ‰ n - i ä¸ªé€‰æ‹©. éœ€è¦æ³¨æ„çš„æ˜¯, è¿™é‡Œ for å¾ªçŽ¯æ˜¯ç”¨æ¥æŽ§åˆ¶å±‚æ•°è€Œä¸æ˜¯çŠ¶æ€çš„.For each position i, it has at most (n - i) - i choices, where i represents the level of the node. Therefore, the time complexity would be O(n!).This case chooses to use a boolean array to indicate the elements that has appeared in the subsolution. This costs O(n). And the depth of the recursive call would be n, so the call stack would take O(n). Thus, the space would be O(2n) ==&gt; O(n). ä»£ç å¦‚ä¸‹:1234567891011121314151617181920212223242526272829303132public class Permutation &#123; public List&lt;List&lt;Integer&gt;&gt; permutation(int[] input) &#123; if (input == null) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(input, new HashSet&lt;&gt;(), new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(int[] input, Set&lt;Integer&gt; occ, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (sub.size() == input.length) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; for (int i = 0; i &lt; input.length; i++) &#123; if (occ.contains(input[i])) &#123; continue; &#125; sub.add(input[i]); occ[i] = true; dfs(input, occ, sub, result); sub.remove(sub.size() - 1); occ[i] = false; &#125; &#125;&#125; è¿™é“é¢˜å¯ä»¥ä¸éœ€è¦é¢å¤–çš„æ•°ç»„æ¥åˆ¤æ–­å½“å‰å±‚çš„å…ƒç´ . ä¾ç„¶åªå…³æ³¨ dfs, ä¸è€ƒè™‘ä¼˜åŒ–, ç¬”èŠ¯â¤~ Permutation IIinput: A linear data structure like an array, a string, etc. With DUPLICATED elements.output: A list of lists of all UNIQUE permutations. æœ‰é‡å¤å…ƒç´ , å¦‚ä½•åŽ»é‡? å…¶å®žå’Œ SubsetII æœ‰é‡å¤å…ƒç´ æ˜¯ä¸€æ ·çš„é“ç†(æŽ’åºçš„åˆ¤æ–­æ¡ä»¶å¯èƒ½ä¼šæœ‰äº›ä¸åŒ). åœ¨æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½éœ€è¦åˆ¤æ–­ä¸€ä¸‹è¿™ä¸ªå…ƒç´ æ˜¯ä¸æ˜¯å½“å‰å±‚çš„ç¬¬ä¸€ä¸ªè¢«ä½¿ç”¨çš„å…ƒç´ , æ‰€ä»¥æ¯ä¸€ä¸ªå±‚éƒ½éœ€è¦ä¸€ä¸ª HashSet. å¦‚æžœå½“å‰å±‚å·²ç»ä½¿ç”¨è¿‡è¿™ä¸ªå…ƒç´ äº†, é‚£ä¹ˆåŽç»­å°±ä¸è€ƒè™‘äº†. At each position i, it has n - i times choices, as same as the regular permutation.A HashSet is used to deduplicate. At each level i, at most n - i space would be taken to save visited element. Space complexity would be n + (n - 1) + (n - 2) + (n - 3) + â€¦. + 2 + 1 = O (n^2). ä»£ç å¦‚ä¸‹:1234567891011121314151617181920212223242526272829303132333435```javapublic class Permutation &#123; public List&lt;List&lt;Integer&gt;&gt; permutation(int[] input) &#123; if (input == null) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); //dfs(input, new HashSet&lt;&gt;(), new ArrayList&lt;&gt;(), result); dfs(input, new ArrayList&lt;&gt;(), result) return result; &#125; private void dfs(int[] input, /*Set&lt;Integer&gt; occ,*/ List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (sub.size() == input.length) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; Set&lt;Integer&gt; occ = new HashSet&lt;&gt;(); for (int i = 0; i &lt; input.length; i++) &#123; if (occ.contains(input[i])) &#123; continue; &#125; sub.add(input[i]); occ[i] = true; dfs(input, occ, sub, result); sub.remove(sub.size() - 1); occ[i] = false; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS ä»Žå…¥é—¨åˆ°æ”¾å¼ƒ II]]></title>
    <url>%2F2018%2F04%2F08%2FDFS%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%20II%2F</url>
    <content type="text"><![CDATA[ä¸“æ³¨ dfs 20å¹´, ç²—ç•¥çš„è¯´ä¸€è¯´åŸºäºŽ subset çš„ðŸŒ°. Partition an Array into K Equal Sum Subsetsinput: An array, and int number k.output: Boolean whether the array can be divided into k subsets with equal sum. æ˜¯å¦èƒ½è¢«ç­‰åˆ†? å¦‚æžœk èƒ½å¤Ÿè¢«æ•°ç»„çš„æ€»å’Œæ•´é™¤, åˆ™æœ‰å¯èƒ½å­˜åœ¨è¿™æ · k ä¸ªå­é›†. æ‰¾åˆ° k ä¸ªæ€»å’Œç­‰äºŽ sum/k çš„å­é›†. å¯ä»¥ä½¿ç”¨å­é›†æ±‚å’Œçš„æ–¹æ³•, æˆ–è€…æ‰¾åˆ°æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„å­é›†çš„è·¯å¾„. æ¯ä¸ªå…ƒç´ åªèƒ½ç”¨ä¸€æ¬¡, æ‰€ä»¥éœ€è¦ä¸€ä¸ªé¢å¤–çš„æ•°æ®ç»“æž„æ¥è®°å½•æ˜¯å¦ä½¿ç”¨è¿‡.It could be nicer if srot the array in descending order It runs k times looking for a qualified subset, so the worst case would be the most O(k n! n), where n! is for seaching String Splitinput: String /char array/etc.output: List&lt;List&gt; /List/ etc. ç»™ä¸€ä¸ªstring(ç›´æŽ¥ç”¨ substring)æˆ–è€… char array( å¯ä»¥ç”¨ StringBuilder), æŠŠå®ƒè¿›è¡Œåˆ‡åˆ†, æ¯ä¸€ä¸ªè¢«åˆ‡åˆ†è¿‡çš„ string é•¿åº¦ä¸èƒ½è¶…è¿‡2. ä¸¾ä¸ªðŸŒ°, â€œabcdâ€, è¿”å›žçš„ç»“æžœæ˜¯, [[a, b, c, d], [a, b, cd], [a, bc, d], [ab, c, d], [ab, cd]].PS: æ¯ä¸€ä¸ª subset éƒ½æ˜¯æœ‰åŒå¼•å·çš„, ç•¥â€¦ æ¯ä¸€ä¸ªå…ƒç´ åªå’Œå®ƒåŽä¸€ä¸ªå…ƒç´ æœ‰å…³ç³». æ¯ä¸€ä¸ªåˆ†æ”¯çš„çŠ¶æ€æ˜¯å®ƒè‡ªå·±æˆ–è€…å®ƒå’ŒåŽé¢ä¸€ä¸ªå…ƒç´ . åŽé¢ä¸€ä¸ªå…ƒç´ è¢«é€‰è¿‡äº†ä¹‹åŽå¤±åŽ»è¿›å…¥ä¸‹ä¸€è½®çš„èµ„æ ¼. The number of element in the input is n. Every element can have at most two branches at each level. Therefore, the time complexity is O(2^n);The height of the tree would be n as well; thus the space would be the call stack which is O(n); ä»£ç å¦‚ä¸‹ 1234567891011121314151617181920212223242526272829303132333435public class SplitString&#123; public List&lt;List&lt;String&gt;&gt; splitString(String s) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); if (s == null) &#123; return new ArrayList&lt;&gt;(); &#125; if (s.length() == 0) &#123; result.add(new ArrayList&lt;&gt;()); return result; &#125; dfs(s, 0, new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(String input, int index, List&lt;String&gt;sub, List&lt;List&lt;String&gt;&gt; result) &#123; if (index == input.length()) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; sub.add(input.substring(index, index + 1)); dfs(input, index + 1, sub, result); sub.remove(sub.size() - 1); if (index + 1 &lt; input.length()) &#123; sub.add(input.substring(index, index + 2)); dfs(input, index + 2, sub, result); sub.remove(sub.size() - 1); &#125; &#125;&#125; å½“ç„¶è¿™é“é¢˜åº”è¯¥æœ‰æ›´ä¼˜åŒ–çš„å†™æ³•, è¿™é‡Œåªè€ƒè™‘ dfs. Valid Permutation of Parenthesesinput: An int n represents the pair of parentheses.output: A list of string with all valid permutation of given number pair of parentheses. åœ¨æ¯ä¸€ä¸ªä½ç½®ä¸Š, åªæœ‰2ä¸ªé€‰æ‹©, å·¦æ‹¬å·è¿˜æ˜¯å³æ‹¬å·. æ”¾ç½®å·¦å³æ‹¬å·çš„å‰ææ¡ä»¶æ˜¯ä»€ä¹ˆ? å¦‚æžœå½“å‰å·²ç»æœ‰äº†nä¸ªå·¦æ‹¬å·, é‚£ä¹ˆå°±ä¸èƒ½å†æ·»åŠ å·¦æ‹¬å·. å¦‚æžœå½“å‰å·¦æ‹¬å·å°äºŽç­‰äºŽå³æ‹¬å·çš„æ•°é‡, é‚£ä¹ˆå°±ä¸èƒ½å†æ·»åŠ å³æ‹¬å·äº†. ä¸¾ä¸ªðŸŒ°, input = 3, output = [&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;]At every position, it has two choices, adding left or right parenthese. It has 2 * n positions. Therefore, time compexity is O(2^2n).The recursive call would have at most 2n frames. Therefore, the space complexity is O(2n). ä»£ç å¦‚ä¸‹:123456789101112131415161718192021222324252627282930public class ValidParentheses&#123; public List&lt;String&gt; validPren (int n) &#123; if (n &lt;= 0) return new ArrayList&lt;&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); dfs(n, 0, 0, new StringBuilder(), result); return result; &#125; private void dfs(int left, int right, StringBuilder bd, List&lt;String&gt; result) &#123; //monitor the number of right parentheses, //then compare the number of left and right if (right &gt;= size) &#123; result.add(new String(bd)); return; &#125; if (left &lt; right) &#123; bd.append("("); dfs(left + 1, right, bd, result); bd.deleteCharAt(bd.length() - 1); &#125; if (right &lt; left) &#123; bd.append(")"); dfs(left, right + 1, bd, result); bd.deleteCharAt(bd.length() - 1; &#125; &#125;&#125; K Sum IIinput: An int array with UNIQUE numbers, k elements that can sum up the target, and a target number.output: List of lists of k intergers that sum up the target. æš´åŠ›æ±‚è§£, åŸºæœ¬ä¸è€ƒè™‘ä¼˜åŒ–. ç»™å®šæ•°ç»„ä¸­çš„å…ƒç´ æ˜¯æ²¡æœ‰é‡å¤çš„, æ‰€ä»¥è¿ž set ä¹Ÿä¸éœ€è¦äº†, åªè¦ä¿è¯æ¯æ¬¡åªçœ‹ index åŽé¢çš„å…ƒç´ å°±å¯ä»¥äº†. é™å®šæ¡ä»¶, æ¯ä¸€ä¸ªç»“æžœé‡Œé¢åªèƒ½æœ‰ k ä¸ªå…ƒç´ . ä¸¾ä¸ªðŸŒ°, [1, 2, 3, 4], k = 2, target = 5. è¿”å›žå€¼ä¸º, [[1, 4][2, 3]], ä¹Ÿå°±æ˜¯è¯´, ä»Žæ¯ä¸€ä¸ª index å‡ºå‘, å¸Œæœ›å®ƒæ¯ä¸€æ¬¡åªå’Œå®ƒåŽé¢çš„å¦å¤–ä¸€ä¸ªæ•°å­—ç›¸åŠ , å¦‚æžœç»“æžœä¸Ž target ç›¸ç­‰, å¹¶ä¸”ç»“æžœé‡Œé¢åªæœ‰2ä¸ªå…ƒç´ , é‚£ä¹ˆå°±è¿”å›žè¿™ä¸ªç»“æžœ.At each level, i represents the number of i-permutations of n, where i is restricted by k. Therefore, at the each level, itâ€™s looking for C(n, 1), C(n, 2), â€¦, C(n, k). To add them up, 1 + C(n, 1) + â€¦ + C(n, k) = (1 + 1)^k = 2^k. If k is equal to the length of input. Then the time complexity is O(2^n).Since we only consider answer with number of k elements, the frame of the call stack would be k, tops. So itâ€™s O(k).ä»£ç å¦‚ä¸‹: 123456789101112131415161718192021222324252627282930313233public class KSum &#123; public List&lt;List&lt;Integer&gt;&gt; kSum(int[] A, int k, int targer) &#123; if (A == null || A.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(A, 0, targer, k, new ArrayList&lt;Integer&gt;(), result); return result; &#125; private void dfs(int[] input, int index, int target, int k, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; //å¯ä»¥åœ¨è¿™é‡Œè¿”å›ž, ä¹Ÿå¯ä»¥åœ¨ for å¾ªçŽ¯é‡Œé¢æŽ§åˆ¶,å…·ä½“å‚è§ DFS I // if (target &lt; 0 || k &lt; 0) &#123; // return; // &#125; //ä¸ºäº†é¿å…å…ƒç´ ç­‰äºŽ target çš„æƒ…å†µ, subSolution é‡Œé¢åªæœ‰1ä¸ªå…ƒç´  if (target == 0 &amp;&amp; k == 0) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; for (int i = index; i &lt; input.length &amp;&amp; k &gt; 0; i++) &#123; if (target - input[i] &gt;= 0) &#123; sub.add(input[i]); dfs(input, i + 1, target - input[i], k - 1, sub, result); sub.remove(sub.size() - 1); &#125; &#125; &#125; &#125; Combination Sum IIinput: An unordered int array with DUPLICATED elements, and a target number.output: All UNIQUE combinations in the array which are candidate numbers sum to the target. ä¾ç„¶æš´åŠ›æ±‚è§£, å³ä½¿è€ƒè™‘ä¼˜åŒ–ä¹Ÿè¦è€ƒè™‘é‡å¤å…ƒç´ çš„é—®é¢˜. é¦–å…ˆ, è¿”å›žç»“æžœå¿…é¡»æ˜¯ unique çš„. å…¶æ¬¡, æ¯ä¸€ä¸ªå…ƒç´ éƒ½åªèƒ½ä½¿ç”¨ä¸€æ¬¡. é‚£ä¹ˆå°±è¦è§£å†³é‡å¤å…ƒç´ èƒ½ä¸èƒ½è¢«é‡å¤é€‰æ‹©çš„é—®é¢˜[ç¬‘]. å’Œ subsets II çš„è§£æ³•ä¸€æ ·. å…ˆæŽ’ä¸ªåº, åæ­£ dfs çš„æ—¶é—´å¤æ‚åº¦å·²ç»æ˜¯æŒ‡æ•°çº§çš„äº†, æŽ’ä¸ªåºæ— ä¼¤å¤§é›…. æŽ’åºé¦–å…ˆç¡®ä¿äº†ç»“æžœçš„æœ‰åºæ€§, æœ‰åŠ©äºŽè¾¨åˆ«æ˜¯å¦é‡å¤, å…¶æ¬¡å¯ä»¥é€‰æ‹© HashSet æˆ–è€… index ä¸¤ç§æ–¹æ³•åŽ»é‡. At each subsolution position i, it runs n - i times looking for candidate. There are n possible positions, where n is the length of input. Therefore, the time complexity is O(n!).Space complexity is O(n) for call stack and using index to deduplicate (without HashSet in each level). 123456789101112131415161718192021222324252627282930313233public CombSum &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] num, int target) &#123; if (num == null || num.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(num, 0, target, new ArrayList&lt;&gt;(), result); return result;&#125; private void dfs(int[] input, int index, int target, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; //Set&lt;Integer&gt; occ = new HashSet&lt;&gt;(); for (int i = index; i &lt; input.length; i++) &#123; //if (target - input[i] &gt;= 0 &amp;&amp; occ.add(input[i]))&#123; if (target - input[i] &gt;= 0 &amp;&amp; (i == index || input[i - 1] != input[i])) &#123; sub.add(input[i]); dfs(input, i + 1, target - input[i], sub, result); sub.remove(sub.size() - 1); &#125; &#125; &#125;&#125; Combination of Coinsinput: A target value and a list of the value of each coins.output: A List of lists of candidates of number of each coins that can add up to the target. æ¯ä¸€å±‚çš„çŠ¶æ€å–å†³äºŽå½“å‰å±‚çš„ target å¤§å°. æ‰€ä»¥éœ€è¦ä¸€ä¸ªåŠ¨æ€çš„å˜é‡æ¥åˆ¤æ–­åˆ†æ”¯æ•°é‡. æˆ‘ä»¬å¸Œæœ›æŠŠå±‚æ•°æŽ§åˆ¶åœ¨ coin çš„æ•°é‡è€Œä¸æ˜¯ target çš„å¤§å°, å› ä¸ºå¦‚æžœ coin çš„é¢å€¼åŒ…å«1çš„è¯, é‚£ä¹ˆå±‚æ•°å°±æ˜¯target çš„å¤§å°, å¦‚æžœ target å¾ˆå¤§, å°±ä¼šçˆ†æ ˆ. At each node of the recursion tree, it has current target / valueOfCoin states. Overall, the one has the most branches is the coin that has smallest value. The states of the node is whatever the factor is. Suppose that factor is k and the number of coin is n. The time complexity is k^n.Space is the number of coins. ä»£ç å¦‚ä¸‹:123456789101112131415161718192021222324252627public class CombCoin&#123; public List&lt;List&lt;Integer&gt;&gt; findCoins(int n, int[] coins) &#123; if (n &lt;= 0) &#123; throw new IllegalArgumentException("Invalid input"); &#125; if (coins == null || coins.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(n, 0, coins, new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(int moneyLeft, int level, int[] coins, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (level == coins.length) &#123; if (moneyLeft == 0) result.add(new ArrayList&lt;&gt;(sub); return; &#125; int factor = moneyLeft / coins[level]; for (int i = 0; i &lt;= factor; i++) &#123; //add 0 ~ factor number of coins sub.add(i); dfs(moneyLeft - coins[level] * i, level + 1, coins, sub, result); sub.remove(sub.size() - 1); &#125; &#125;&#125; Cartesian Productinput: A 2D array with different length of column in each row.output: List of lists of Catesian product such that AÃ—BxC = {(x,y,z)|xâˆˆA âˆ§ yâˆˆB âˆ§ zâˆˆC}; ä»Žæ¯ä¸€è¡Œçš„ç¬¬0åˆ—å¼€å§‹éåŽ†, ç›´åˆ°æœ€åŽä¸€è¡Œ, index == input.length; æ¯ä¸€ä¸ªè¡Œçš„å…ƒç´ é•¿åº¦æœ‰å¯èƒ½ä¸ä¸€è‡´, è€ƒè™‘è¶Šç•Œé—®é¢˜. è¿™é‡Œé¢ for loop ä¸å†æ˜¯æŽ§åˆ¶å±‚æ•°è€Œæ˜¯æŽ§åˆ¶æ¯ä¸€å±‚çš„åˆ†æ”¯, æ‰€ä»¥éœ€è¦é€€å‡ºæ¡ä»¶. ä¸¾ä¸ªðŸŒ°, ç»™å®šä¸€ä¸ªäºŒç»´æ•°ç»„[[1, 2, 3],[4, 5],[6, 7, 8]], å®ƒçš„å±‚æ•°å’Œ row ç›¸å…³, åˆ†æ”¯æœ€å¤šä¸è¶…è¿‡column çš„æœ€å¤§å€¼. Suppose the matrix has n rows and m columns. It has at most n levels, and at each level, a node has at most m branches. Thus time complexity is O(m^n);No extra space is used besides the call stack, which is the number of row, O(n). ä»£ç å¦‚ä¸‹:123456789101112131415161718192021222324252627public class CarteProduct &#123; public List&lt;List&lt;Integer&gt;&gt; getSet(int[][] input) &#123; if (setList == null || setList.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(input, 0, new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(int[][] input, int row, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (row == input.length) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; for (int i = 0; i &lt; input[row].length; i++) &#123; sub.add(input[row][i]); dfs(input, row + 1, sub, result); sub.remove(sub.size() - 1); &#125; &#125;&#125; All Factors Of A Numberinput: An int.output: A list of list of all candidates that the production is given number. ä»Ž2å¼€å§‹æ‰¾åˆ° input çš„å®Œå…¨å¹³æ–¹æ ¹çš„æ•´æ•°ä¸ºæ­¢. éœ€è¦æ³¨æ„çš„æ˜¯, ä»€ä¹ˆæ—¶å€™ç»§ç»­å‘ä¸‹é™¤, ä»€ä¹ˆæ—¶å€™åœæ­¢. å’Œå‰é¢æ‰¾ sum çš„é¢˜å·®ä¸å¤š, åªæ˜¯éœ€è¦æ³¨æ„ä¸€ä¸‹ä¹˜é™¤æ³•çš„ç»†èŠ‚. For each number at a level, it has sqrt(n) choices to run (although situations are optimized in the code). The recursive call has the most sqrt(n) times. The time complexity is O(sqrt(n) ^ sqrt(n)). LOGN^FACTORSapces is the call stack which is sqrt of n. ä»£ç å¦‚ä¸‹:123456789101112131415161718192021222324252627public class AllFactors&#123; public List&lt;List&lt;Integer&gt;&gt; factors(int n) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(2, n, new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(int startPoint, int quotient, ArrayList&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (quotient &lt;= 1) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; for (int i = startPoint; i &lt;= quotient; i++) &#123; //corner case: n = 2 int curFactor = i * i &lt;= quotient ? i : quotient; //åˆ’é‡ç‚¹ if (quotient % curFactor == 0) &#123; sub.add(curFactor); dfs(curFactor, quotient / curFactor, sub, result); sub.remove(sub.size() - 1); &#125; if(i * i &gt; quotient) break; &#125; &#125;&#125; æ„Ÿè°¢@æ™¯é˜³åŒå­¦çš„å‹æƒ…æ”¯æŒ~ç¬”èŠ¯â¤]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS ä»Žå…¥é—¨åˆ°æ”¾å¼ƒI]]></title>
    <url>%2F2018%2F04%2F06%2FDFS%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%20I%2F</url>
    <content type="text"><![CDATA[Depth First Search æ˜¯ä¸€ç§åŸºäºŽæ ‘çŠ¶(Tree) æˆ–è€…å›¾çŠ¶(graph)çš„æœç´¢ç®—æ³•, æœ¬è´¨æ˜¯ä»Žä¸€ä¸ªèŠ‚ç‚¹(root)å‡ºå‘, å‘æ¯ä¸€ä¸ªåˆ†æ”¯è¿›è¡Œæœç´¢, è€Œå¯¹äºŽæ¯ä¸€ä¸ªåˆ†æ”¯æ¥è¯´, å®ƒæœ¬èº«å°±æ˜¯ä¸€ä¸ªèŠ‚ç‚¹, ä»Žè¿™ä¸ªèŠ‚ç‚¹ç»§ç»­å‘å®ƒå¯èƒ½äº§ç”Ÿçš„åˆ†æ”¯è¿›è¡Œæœç´¢, æœ€ç»ˆåœ¨æœç´¢æ‰€æœ‰çš„å¯èƒ½æ€§çš„è¿‡ç¨‹ä¸­æ‰¾åˆ°ç»“æžœ. ä¹Ÿå°±æ˜¯æ‰€è°“çš„æ™®éæ’’ç½‘å§. SubsetI SubsetII Partition an Array into K Equal sum subsets Combination of K I Combination of K II Combination of Coins Combination of Factors PermutationI PermutationII Valid ParenthesesI Valid ParenthesesII N-QueenI N-QueenII Subset Iinput: A linear data structure, such as an array or a string.output: A list of lists of all unique subsets. DFS çš„æ ¸å¿ƒå°±æ˜¯å›žæº¯( backtracking), ä¹Ÿå°±æ˜¯è¯´, è¿™äº›åˆ†æ”¯ä»Žå“ªé‡Œæ¥çš„, æœ€åŽæ¸…é™¤äº†æ²¿é€”é™„åŠ çš„çŠ¶æ€å†å›žåˆ°å“ªé‡ŒåŽ». dfs å¯ä»¥ä½¿ç”¨ for å¾ªçŽ¯æ¥æŽ§åˆ¶ recursion çš„å±‚æ•°. åœ¨è¿™é‡Œ, for å¾ªçŽ¯çš„ç»ˆæ­¢æ¡ä»¶å°±æ˜¯ dfs çš„ç»ˆæ­¢æ¡ä»¶. å±€éƒ¨å˜é‡ i ä½œä¸ºå‚æ•° index ä¼ å…¥å‡½æ•° dfs, å½“ i ç­‰äºŽ input çš„é•¿åº¦çš„æ—¶å€™, å‡½æ•°è¿”å›ž. å…¶å®žå’Œæ™®é€šçš„ for loop æ˜¯ä¸€æ ·çš„, åªè¦æ˜Žç™½ index å’Œ i åˆ†åˆ«è¡¨ç¤ºçš„æ˜¯ä»€ä¹ˆ. è¿™é‡Œåœ¨æœ€å¤–å±‚çš„for loop æ‰§è¡Œäº† n æ¬¡, n æ˜¯ input çš„é•¿åº¦, è€Œæ¯ä¸€æ¬¡è°ƒç”¨çš„æ—¶å€™ i è¿›è¡Œäº†ä¸€æ¬¡ + 1çš„æ“ä½œ, i æ¬¡è°ƒç”¨çš„dfs ä¸­çš„ for loop ä¼šæ‰§è¡Œ (n - i) - i æ¬¡, åŒæ ·çš„, å½“ i çš„é•¿åº¦ç­‰äºŽ input çš„é•¿åº¦çš„æ—¶å€™å‡½æ•°è¿”å›ž, ä¸€æ¬¡é€€å›žä¸Šä¸€å±‚è°ƒç”¨å®ƒçš„é‚£ä¸ªå¾ªçŽ¯ä¸­, å†ç»§ç»­. For a position i in the input, it has (n - i) - i (where n - i is the size of sub-problem, f(n - 1))choices to run, where n is the length of the input. Every time when the dfs is being called, the size of the problem reduces to n - i, therefore T(n) = 2T(n - 1), O(2^n).Since itâ€™s recursion, the call stack would be the length of the input, which is O(n). ä»£ç å¦‚ä¸‹:123456789101112131415161718192021222324252627282930class Subsets &#123; public List&lt;List&lt;Integer&gt;&gt; findSubsets(int[] input) &#123; if (input == null) &#123; return new ArrayList&lt;&gt;(); &#125; if (nums.length == 0) &#123; results.add(new ArrayList&lt;Integer&gt;()); return results; &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(input, 0, new ArrayList&lt;&gt;()); return res; &#125; private void dfs(int[] input, int index, ist&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result)&#123; result.add(new ArrayList&lt;Integer&gt;(subSolution)); for (int i = index; i &lt; input.length; i++) &#123; subSolution.add(input[i]); dfs(input, i + 1, result); subSolution.remove(sobSolution.size() - 1); &#125; &#125;&#125; é¦–å…ˆå¦‚æžœä¸æ˜¯ç”¨ for å¾ªçŽ¯æ¥æŽ§åˆ¶ recursion çš„å±‚æ•°, é‚£ä¹ˆ recursion å°±ä¸€å®šéœ€è¦ä¸€ä¸ªé€€å‡ºæ¡ä»¶. ä¹Ÿå¯ä»¥ä½¿ç”¨ for loop æ¥æ¯ä¸€å±‚çš„çŠ¶æ€, æˆ–è€…è¯´æ¯ä¸€ä¸ªä½ç½®ä¸Šçš„å¯èƒ½æ€§, æˆ–è€…æ¯ä¸€ä¸ªå…ƒç´ å¯èƒ½äº§ç”Ÿçš„åˆ†æ”¯ä¸ªæ•°ç­‰ç­‰. é‚£ä¹ˆ dfs çš„ç»ˆæ­¢æ¡ä»¶å°±ä¸å†æ˜¯ for å¾ªçŽ¯çš„ç»ˆæ­¢æ¡ä»¶äº†, è€Œéœ€è¦æ˜Žç¡®çš„å†™å‡ºæ¥. é€šå¸¸æ˜¯å½“ä¸‹æ ‡æŒ‡å‘äº†input é•¿åº¦ + 1çš„ä½ç½®çš„æ—¶å€™. é‚£ä¹ˆå±€éƒ¨å˜é‡ i è¡¨ç¤ºçš„å°±æ˜¯å¯¹äºŽå½“å‰ä¸‹æ ‡æ¥è¯´, å®ƒæœ‰å‡ ç§é€‰æ‹©, åªæ˜¯ i ä¸å†ä»£è¡¨å¯é€‰æ‹©å…ƒç´ çš„ä¸‹æ ‡äº†. æ‰€ä»¥å‚æ•°éœ€è¦ä½¿ç”¨ index. for loop çš„æ„ä¹‰æ˜¯åœ¨ä»¥å½“å‰ index ä¸ºèŠ‚ç‚¹è°ƒç”¨2æ¬¡ dfs, å¦‚æžœ i æ˜¯0çš„è¯, åŠ ä¸Š index å¯¹åº”çš„å…ƒç´ , i = 1æ—¶è¿”å›žä¸Šä¸€å±‚çš„çŠ¶æ€, å¹¶ä¸”è¿›è¡Œä¸‹ä¸€æ¬¡çš„é€’å½’è°ƒç”¨ (ä¹Ÿå°±æ˜¯ä¸åŠ çš„æƒ…å†µ). For element in a position i, it has two states, eighter added or removed. The it has n positions, where n is the length of the input. Thus, time complexity is 2^n.Space complexity is the call stack layers, which is O(n). ä»£ç å¦‚ä¸‹, 123456789101112131415161718private void dfs(int[] input, int index, List&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (index == input.length) &#123; result.add(new ArrayList&lt;&gt;(subSolution); return; &#125; for (int i = 0; i &lt;= 1; i++) &#123; if (i == 0) &#123; subSolution.add(input[index]); &#125; else &#123; subSolution.remove(subSolution.size() - 1); &#125; dfs(input, index + 1 , result); &#125;&#125; å› ä¸ºåªæœ‰2ç§çŠ¶æ€, æ‰€ä»¥å…¶å®žä¸éœ€è¦ä¸€ä¸ª for å¾ªçŽ¯. 123456789101112131415private void dfs(int[] input, int index, List&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (index == input.length) &#123; result.add(new ArrayList&lt;&gt;(sobSolution)) &#125; subSolution.add(input[index]); dfs(input, index + 1, subSolution, result); subSolution.remove(sobSolution.size() - 1); dfs(input, index + 1, subSolution, result);&#125; Subset IIæœ‰é‡å¤å…ƒç´ æ€Žä¹ˆåŠž?é€šå¸¸æœ‰ä¸¤ç§è§£å†³æ–¹æ¡ˆ, æŽ’åº HashSet/HashMap(æ ¹æ®å…·ä½“è¦æ±‚) å› ä¸º dfs çš„æ—¶é—´å¤æ‚åº¦ä¸€å®šæ˜¯é«˜äºŽæŽ’åºçš„, æ‰€ä»¥åœ¨æ—¶é—´å¤æ‚åº¦ä¸Šé¢æ²¡æœ‰åŒºåˆ«. ç©ºé—´å¤æ‚åº¦æ¥è¯´, å¦‚æžœæ˜¯ä¸€ä¸ª array, é‚£ä¹ˆæŽ’åºçš„ç©ºé—´å¤æ‚åº¦å°±æ˜¯ call stack çš„å±‚æ•°, å¦‚æžœæ˜¯ä¸€ä¸ª String, é‚£ä¹ˆæŽ’åºå°±ä¸€å®šè¦æŠŠ String è½¬æ¢æˆ array ä¹‹åŽå†æŽ’åº. æ‰€ä»¥å°±å…·ä½“æƒ…å†µå…·ä½“åˆ†æžå§. æŽ’åºçš„æ–¹æ³• è¿™é‡Œå°±ç”¨åˆ°äº† Subset I é‡Œé¢å¯¹äºŽ index å’Œ i çš„ç‰©ç†æ„ä¹‰çš„åˆ†æž, å½“ i == index çš„æ—¶å€™æ˜¯åœ¨å½“å‰å±‚ç¬¬ä¸€æ¬¡è¿›å…¥ for loop çš„æƒ…å†µ, ä¹‹åŽåœ¨è°ƒç”¨dfs çš„æ—¶å€™, æŠŠ i æ‰€åœ¨å…ƒç´ çš„åŽä¸€ä¸ªå…ƒç´ å½“åš index å‚æ•°ä¼ ç»™ dfs. æ‰€ä»¥å½“å‡½æ•°è¿”å›žä¹‹åŽ, local å˜é‡è¢« GC, i ä¾ç„¶æ˜¯ä½œä¸º for loop çš„è‡ªå¢žå˜é‡å­˜åœ¨. æ‰€ä»¥å¯¹äºŽä¸€ä¸ªæŽ’åºçš„æ•°ç»„æ¥è¯´, åªæœ‰åœ¨å½“å‰å±‚ for loop ç¬¬ä¸€æ¬¡å¾ªçŽ¯çš„æ—¶å€™ i å’Œ index æŒ‡å‘çš„æ˜¯åŒä¸€ä¸ªå…ƒç´ . é‚£ä¹ˆå½“ index å’Œ i ä¸æ˜¯æŒ‡å‘åŒä¸€ä¸ªå…ƒç´ çš„æ—¶å€™( i è‡ªå¢žå¾ªçŽ¯), å¦‚æžœ index å’Œ i ä¸‹æ ‡æŒ‡å‘çš„å…ƒç´ ä¾ç„¶ç›¸åŒ, å°±è¯´æ˜Žæ˜¯é‡å¤å…ƒç´ , é‚£ä¹ˆä¹…å¯ä»¥ç›´æŽ¥è·³è¿‡(ä¸é€‰çš„æƒ…å†µ). ç®€è€Œè¨€ä¹‹, åªæœ‰æ»¡è¶³æŸç§æ¡ä»¶æ‰ä»Žå½“å‰èŠ‚ç‚¹å‡ºå‘, è°ƒç”¨ dfs. ä»£ç å¦‚ä¸‹: 12345678910111213141516public dfs(int[] input, int index, List&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result) &#123; result.add(new ArrayList&lt;&gt;(subSolution)); for (int i = index; i &lt; input.length; i++) &#123; if (i != index &amp;&amp; input[i] != input[i - 1]) &#123; ///i != index ä¿è¯äº†ä¸ä¼šè¶Šç•Œ, å³ä½¿ index == 0 çš„æƒ…å†µ. subSolution.add(input[i]); dfs(input, i + 1, subSolution, result); subSolution.remove(subSolution.size() - 1); &#125; &#125;&#125; å¦‚æžœä¸ä½¿ç”¨ for å¾ªçŽ¯ä½œä¸ºé€’å½’è°ƒç”¨çš„ç»ˆæ­¢æ¡ä»¶åˆ¤æ–­, åŸºäºŽå¯¹æ¯ä¸€å±‚ä¼ å…¥å‚æ•° index çš„é€‰å–, å®ƒçš„æ ‘çŠ¶ç»“æž„åº”è¯¥æ˜¯è¿™æ ·çš„. å¯ä»¥çœ‹åˆ°, ä»¥ä¸€ä¸ªé‡å¤å…ƒç´ ä¸ºèŠ‚ç‚¹å±•å¼€çš„é€’å½’è°ƒç”¨æ‰€äº§ç”Ÿçš„ subset æ˜¯å’Œå®ƒç¬¬ä¸€æ¬¡å‡ºçŽ°çš„èŠ‚ç‚¹çš„ subset å®Œå…¨ä¸€è‡´. é‚£ä¹ˆåœ¨å½“å‰å±‚åˆ¤æ–­ index æ˜¯å¦ç¬¬ä¸€æ¬¡å‡ºçŽ°, å¦‚æžœæ˜¯, é‚£ä¹ˆå°±è·³è¿‡. ä»£ç å¦‚ä¸‹:12345678910111213141516171819public dfs(int[] input, int index, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (index == input.length()) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; sub.add(input[index]); dfs(input, index + 1, sub, result); sub.remove(sub.size() - 1); while (index + 1 &lt; input.length &amp;&amp; input[index] == input[index + 1]) &#123; index++; &#125; dfs(input, index + 1, sub, result);&#125; HashSet çš„æ–¹æ³• å‡è®¾é‡å¤å…ƒç´ åªä¿ç•™ä¸€ä¸ª, é‚£ä¹ˆè‡ªç„¶çš„æƒ³åˆ°å¯ä»¥æŠŠä½¿ç”¨è¿‡çš„å…ƒç´ æ”¾åˆ° HashSet é‡Œé¢. éœ€è¦æ³¨æ„çš„æ˜¯, å½“æˆ‘ä»¬è¿”å›žä¸Šä¸€å±‚çš„æ—¶å€™, æœ‰å¯èƒ½è¿˜ä¼šç”¨åˆ°ä¹‹å‰å–è¿‡çš„å…ƒç´ , é‚£ä¹ˆè¿™ä¸ª HashSet å°±åªèƒ½ä½œç”¨åœ¨å½“å‰å±‚. ä¹Ÿå°±æ˜¯è¯´, å½“index ä½œä¸º node ä¼ å…¥çš„æ—¶å€™, æ²¡è¿›å…¥ä¸€æ¬¡ for loop å°±ä¼šå½¢æˆä¸€ä¸ªæ–°çš„ HashSet, å½“å‡½æ•°è¿”å›žçš„æ—¶å€™, æ‰€æœ‰å½“å‰å±‚å­˜åœ¨ set é‡Œé¢çš„å…ƒç´ éƒ½ä¸ä¼šè¢«æ‰§è¡Œ. At each level, it runs n - i times looking for candidates, so the time comlexity would be as same as the regular subset.However, if use a Hashset at each level to save visited elements, it would cost O(n^2) space.ä»£ç å¦‚ä¸‹: 1234567891011121314151617public dfs(int[] input, int index, List&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result) &#123; result.add(new ArrayList&lt;&gt;(subSolution)); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = index; i &lt; input.length; i++) &#123; if (set.add(input[i])) &#123; subSolution.add(input[i]); dfs(input, i + 1, subSolution, result); subSolution.remove(subSolution.size() - 1); &#125; &#125;&#125; Subsets çš„è§£æ³•æœ‰å¾ˆå¤šç§, æœ€ç›´è§‚çš„æ˜¯æ·±åº¦ä¼˜å…ˆæœç´¢(DFS), å¦å¤–ä¹Ÿå¯ä»¥ä½¿ç”¨å®½åº¦ä¼˜å…ˆæœç´¢(BFS), æ ¹æ®å…¶ç‰¹æ€§, å¯¹äºŽæ¯ä¸€ä¸ªå…ƒç´  e æ¥è¯´éƒ½æœ‰0 æˆ–è€…1ä¸¤ä¸ªçŠ¶æ€è¿˜å¯ä»¥ä½¿ç”¨bit operation, æˆ–è€…ç›´æŽ¥ä½¿ç”¨å¤šå±‚ for å¾ªçŽ¯, æ¯ä¸€å±‚æŽ§åˆ¶2ä¸ªé€‰æ‹©, åŠ å…ƒç´ ä¸Žä¸åŠ å…ƒç´ .é’ˆå¯¹æ¯ä¸€ç§dfs è¿˜å¯ä»¥æœ‰ä¸€äº›å°å°çš„ optimization. æš‚ä¸”ä¸è¡¨. ä¸“æ³¨æ˜¯ä¼˜è‰¯å“è´¨, è¿™é‡Œå°±åªå†™ dfs äº†. ç¬”èŠ¯~â¤]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web ApplicationèƒŒåŽçš„é‚£äº›äº‹å„¿]]></title>
    <url>%2F2018%2F04%2F06%2FWeb-Application%E8%83%8C%E5%90%8E%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[å½“ä½ åœ¨åœ°å€æ ä¸­è¾“å…¥â€ www.google.com&quot; ä¹‹åŽå‘ç”Ÿäº†ä»€ä¹ˆ? é¦–å…ˆæµè§ˆå™¨ä¼šè¯†åˆ« URL åœ°å€: åŒ…æ‹¬åè®®( http/https/ftp), åŸŸågoogle.com, ä»¥åŠå®ƒå¯¹åº”çš„ç«¯å£å·. http é»˜è®¤ç«¯å£å·ä¸º80, https ç«¯å£å·ä¸º443, ftp ç«¯å£å·ä¸º21. æµè§ˆå™¨ä¼šçŽ°åœ¨å„ç§ cache ( browser cache, OS cache, DNS cache, etc)ä¸­æŸ¥æ‰¾, å¦‚æžœéƒ½æ‰¾ä¸åˆ°å°±æŠŠä»»åŠ¡ä¸¢ç»™ ISPâ€™s DNS (Internet Service Provider). ISP ä½œä¸ºæœåŠ¡ä¾›åº”å•†, ç§¯æžæœ¬ç€ç§¯æžå“åº”å®¢æˆ·éœ€æ±‚çš„åŽŸåˆ™ä»Žé«˜åˆ°ä½Ž, ä»Žè¿œåˆ°è¿‘çš„è¿›è¡Œé€’å½’æœç´¢. ç›´åˆ°æ‰¾åˆ°è¿™ä¸ªåœ°å€æ‰€åœ¨çš„æ‰€æœ‰æœåŠ¡å™¨, è¿”å›žæœ€è¿‘çš„, æ•ˆæžœæœ€å¥½çš„é‚£ä¸ªåœ°å€ç»™æµè§ˆå™¨. æµè§ˆå™¨å°±å°±å¯ä»¥éªšéªšçš„æ‹¿ç€è¿™ä¸ªåœ°å€å‘æœåŠ¡å™¨å‘é€è¯·æ±‚( get, post, etc). æœåŠ¡å™¨ä¼šè¿”å›žç»™æµè§ˆå™¨ä¸€ä¸ªç¡®åˆ‡çš„åœ°å€. çŽ°åœ¨æµè§ˆå™¨ç¡®è®¤è¿™ä¸ªåœ°å€æ˜¯æœ‰æ•ˆçš„äº†, ç„¶åŽä¸è¦è„¸çš„åˆå‘é€äº†ä¸€æ¬¡ä¸€æ¨¡ä¸€æ ·çš„è¯·æ±‚. è¿™ä¸€æ¬¡ server ä¼šæ´¾ handler æ¥å¤„ç†è¿™ä¸ªè¯·æ±‚, è¯»å–å®ƒçš„å‚æ•°, (ä»¥åŠæ›´æ–°æœåŠ¡å™¨ç«¯çš„å†…å®¹). handler ç»“æŸå·¥ä½œä¹‹åŽä¼šç”Ÿæˆä¸€ä¸ª HTML çš„å›žå¤, ç„¶åŽæœåŠ¡å™¨ä¼šæŠŠè¿™ä¸ªå›žå¤äº¤ç»™æµè§ˆå™¨. (HTTP/1.1 200 OK) æµè§ˆå™¨æ”¶åˆ°è¿™ä¸ªå›žå¤ä¹‹åŽå°±ä¼šå¯è§†åŒ–è¿™ä¸ª HTML çš„å†…å®¹, å¹¶ä¸”å‘æœåŠ¡å™¨å‘é€è¯»å–å†…å®¹çš„è¯·æ±‚å¹¶æŽ¥æ”¶è¿™äº›æ–‡ä»¶. (Images, CSS, JS files, etc) æ‰€è°“åè®®æ˜¯ä¸ºäº†è®©åŒæ–¹é€šè®¯å¯ä»¥ç†è§£, è¿™é‡Œé€šå¸¸æˆ‘ä»¬ä¼šä½¿ç”¨ HTTP åè®®. ä¸ºäº†ç¡®ä¿å’Œç›®æ ‡è¿›ç¨‹é“¾æŽ¥æ­£ç¡®, ä½¿ç”¨ TCP åè®®. IP åœ°å€æ˜¯ä¸ºäº†ä¿è¯è¯·æ±‚èƒ½å‘é€åˆ°æ­£ç¡®çš„æœºå™¨ä¸Š. å¯¹ä¸€ä¸ª Web Application æ¥è¯´, å®ƒçš„èŒèƒ½èŒƒå›´å°±æ˜¯åœ¨å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯æ”¶åˆ°è¯·æ±‚ä¹‹åŽ,èƒ½å¤Ÿæ­£ç¡®å¤„ç†. å…³äºŽ Tomcatå°±æ˜¯ä¸€ä¸ªç”¨æ¥å¤„ç†å„ç§ Web Application åŸºæœ¬æ“ä½œçš„æ¡†æž¶. ä¾‹å¦‚å¦‚ä½•æŽ¥å— HTTP çš„è¯·æ±‚, å¦‚ä½•å‘é€ HTTP çš„ç»“æžœ, å¦‚ä½•è°ƒç”¨ä¸Ž HTTP è¯·æ±‚ç›¸å…³çš„è¿›ç¨‹, å¦‚ä½•å»ºç«‹ TCP çš„é“¾æŽ¥, ä»¥åŠå»ºç«‹è¿žæŽ¥åŽå¦‚ä½•æŠŠ HTTP è¯·æ±‚çš„å¤„ç†ç»“æžœè¿”å›žç»™å®¢æˆ·ç«¯. å®ƒå¯ä»¥è¿è¡Œåœ¨æœ¬åœ°æˆ–è€…è¿œç¨‹æœåŠ¡å™¨ä¸Š.ä½œä¸ºå¼€å‘äººå‘˜åªéœ€è¦å¤„ç†æŽ¥æ”¶åˆ°è¯·æ±‚ä¹‹åŽå’Œè¿”å›žç»“æžœè¿™ä»¶çš„è¿™ä¸€æ®µæ—¶é—´å†…çš„éœ€è¦åšçš„æ“ä½œ. å¤§å¤§ç®€åŒ–äº†å¼€å‘äººå‘˜çš„æ“ä½œå¤æ‚åº¦. ä¸€ä¸ªç®€å•çš„ Web Application ä¼šéµå¾ªä¸€ä¸ªç®€å•çš„3å±‚é€»è¾‘: PLD Presentation Tier: å¦‚ä½•å±•ç¤ºç»™å®¢æˆ· Frontend HTML, CSS, Javascript, etc. Data Tier: å¦‚ä½•å­˜å‚¨æ•°æ® SQL MongoDB, MySQL, etc. Logic Tier: å¦‚ä½•å¤„ç†æ•°æ® Backend Java, Go, Python, etc. ç®€è¿° HTTP è¯·æ±‚: Request Line ( è¯·æ±‚ç±»åž‹( get, post, etc) , è®¿é—®çš„èµ„æº( host åœ°å€çš„ç›¸å¯¹è·¯å¾„,è®¿é—®ä¹‹åŽè§¦å‘çš„è·¯å¾„), HTTP/1.1(åè®®ç‰ˆæœ¬)) Request Header (é¢å¤–ä¿¡æ¯, æ”¯æŒè¯­è¨€, æµè§ˆå™¨ç±»åž‹ç­‰) Request Message Body (å¯¹å†…å®¹è¿›è¡Œæ›´æ”¹) HTTP RESPONSE: Status Line ( åè®®ç‰ˆæœ¬, çŠ¶æ€ç  200, 404, 500, etc., çŠ¶æ€ä¿¡æ¯) Response Headers (Server ç‰ˆæœ¬, è¿”å›žç±»åž‹, etc) Response Message Body å¯¹äºŽ Message Body é€šå¸¸ä½¿ç”¨ Json (Javascript Object Notation)æ ¼å¼, æ¯”èµ· XML æ›´åŠ ç®€æ´, è€Œå´ key, value pair çš„æœç´¢æ•ˆçŽ‡æ›´é«˜.RPC (Remote Procedure Call): å¯¹äºŽ HTTP è¯·æ±‚è¿›è¡Œå¤„ç†ç„¶åŽè¿”å›žç›¸å¯¹åº”çš„ç»“æžœè¿™ä¸ªè¿‡ç¨‹.å¯¹äºŽ Java æ¥è¯´, Java Servlet æ˜¯ä¸“é—¨ç”¨æ¥å¤„ç†å®¢æˆ·ç«¯å‘åˆ°æœåŠ¡å™¨ç«¯çš„è¯·æ±‚çš„(rpc). é€šå¸¸ä½¿ç”¨ HTTP çš„è¯·æ±‚ç±»åž‹æ˜¯ Get å’Œ Post. é‚£ä¹ˆä¸ºä»€ä¹ˆåå‘äºŽç”¨ Post è€Œä¸æ˜¯ç”¨ Put å‘¢?å› ä¸º Put æ˜¯å¹‚ç­‰( idempotent) çš„æ“ä½œ, è€Œ Post ä¸æ˜¯. ä»€ä¹ˆæ˜¯å¹‚ç­‰å‘¢?å¯¹äºŽä¸€ä¸ªæ“ä½œå’Œå¤šä¸ªæ“ä½œäº§ç”Ÿçš„ç»“æžœæ˜¯ç›¸åŒçš„, è¿™ç§æ“ä½œå«åšå¹‚ç­‰. è€Œæ¯ä¸€ä¸ªæ“ä½œäº§ç”Ÿçš„ç»“æžœéƒ½ä¸ç›¸åŒçš„æ“ä½œæˆä¸ºéžå¹‚ç­‰æ“ä½œ.å¦‚æžœå¯¹æŸä¸ªæ–‡ä»¶è¿›è¡Œä¸€ä¸ªæ›´æ–°æ“ä½œ, æˆ‘ä»¬å¸Œæœ›ä¿æŒç»“æžœçš„ä¸€è‡´æ€§.æ‰€ä»¥ä½¿ç”¨ Post. ç®€è¿° URL: protocal://hostname:port/endpoint?queryé€šå¸¸ port æ˜¯ä¸å†™çš„, å› ä¸º æ¯ä¸€ä¸ª protocal æœ‰é»˜è®¤çš„ç«¯å£å·ç . é™¤éžæˆ‘ä»¬å¸Œæœ›ç›‘å¬ç‰¹å®šçš„æŸä¸ªè¿›ç¨‹.endpoint å¯¹åº”çš„æ˜¯æˆ‘ä»¬å¸Œæœ›è§¦å‘çš„çš„è¿›ç¨‹. ä½¿ç”¨ REST è®¾è®¡Web Service:ä½¿ç”¨ HTTP method å¯¹åº”è¯·æ±‚, å‡å°‘æœåŠ¡å™¨ç«¯çš„æ“ä½œ, ç›´æŽ¥é€šè¿‡HTTP request åˆ¤æ–­ç”¨æˆ·éœ€æ±‚.server å¯ä»¥é€šè¿‡URLæ¥åˆ¤æ–­è¯·æ±‚å¯¹åº”çš„æ˜¯å“ªä¸€ä¸ªæ–‡ä»¶/è¿›ç¨‹( service).è¯·æ±‚å’Œè¯·æ±‚ä¹‹é—´ç›¸äº’ç‹¬ç«‹çš„, server å°±ä¸éœ€è¦è®°å½•ä¸€ä¸ªè¯·æ±‚çš„çŠ¶æ€ä»¥ä¾¿äºŽå¤„ç†ä¸‹ä¸€ä¸ªè¯·æ±‚(å¤„äºŽ stateless çŠ¶æ€).æ¯ä¸ªè¯·æ±‚å¯¹åº”ä¸€ä¸ªæ“ä½œ.æå‡æ•°æ®å¤„ç†é‡, å› ä¸ºæ¯ä¸€ä¸ªè¯·æ±‚éƒ½æ˜¯ç›¸å¯¹ç‹¬ç«‹çš„, æ‰€ä»¥ server ä¸éœ€è¦è®°å½•ä»»ä½•ä¸€ä¸ªè¯·æ±‚æ¥å¤„ç†ä¸‹ä¸€ä¸ªè¯·æ±‚,å› æ­¤ server æ˜¯æ— çŠ¶æ€çš„, æ‰€ä»¥å½“è¿›è¡Œæ‰©å±•çš„æ—¶å€™ä¸éœ€è¦è€ƒè™‘ server çš„çŠ¶æ€, å¯ä»¥ç®€å•çš„ä½¿ server è¿è¡Œåœ¨å¤šä¸ªä¸åŒçš„æœºå™¨ä¸Š(å¹³è¡Œæ‰©å±•). æ‰©å±•æ€§èƒ½é«˜( scalibility). DataBase:ER (Entity Relationship) model: åªåŒ…å«ä¸¤ç§æ•°æ®ç±»åž‹( Entity( å¯ä»¥å®žä¾‹åŒ–), Entity ä¹‹é—´çš„å…³ç³»(ä¸èƒ½å®žä¾‹åŒ–))MySQL: Widely used open source relational database manaegement system. Table: æ‹¥æœ‰ç›¸åŒå±žæ€§çš„æ•°æ®é›†åˆ. æ¯ä¸€åˆ—å¯¹åº”ä¸€ä¸ªå±žæ€§. Row: åŒ…å«å®Œæ•´ä¿¡æ¯çš„ä¸€ä¸ª item. Column :å±žæ€§. Schema: table åˆ›å»ºæ—¶å€™çš„ç»“æž„(éƒ½æœ‰ä»€ä¹ˆå±žæ€§, æ¯ä¸€ç§å±žæ€§æœ‰ä»€ä¹ˆç±»åž‹, å…¶ä»–é™åˆ¶æ¡ä»¶ç­‰). Consistency: ä¿æŒä¸€è‡´æ€§, ä½†æ˜¯æ…¢. æ•°æ®è€¦åˆåº¦é«˜. NoSQL: Json-like distributed system using horizontal scaling. No schema. More flexible. Collection: æ•°æ®é›†åˆ.ä¸è¦æ±‚æ¯ä¸€æ¡æ•°æ®æ‹¥æœ‰ç›¸åŒçš„å±žæ€§. Document: åŒ…å«å®Œæ•´ä¿¡æ¯çš„ä¸€ä¸ª item. Field: å±žæ€§. (may vary from document to document) Avalibility: åŠæ—¶åŒæ­¥, é€Ÿåº¦å¿«. ä½†æ˜¯æ•°æ®æœ‰å¯èƒ½ä¸å¤ªä¸€è‡´.æ•°æ®ä¹‹é—´çš„è€¦åˆåº¦ä½Ž. CAP: Consistency: Every request will receive the most recent data. Availability: Every request will receive a response, which may not be up to the minute, without delay. Partition tolerance: Trade off consistency and availability for distributed system.]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web Application</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure V Tree III]]></title>
    <url>%2F2018%2F04%2F05%2FData%20Structure%20V%20Tree%20iii%2F</url>
    <content type="text"><![CDATA[â”€=â‰¡Î£((( ã¤â€¢Ì€Ï‰â€¢Ì)ã¤ BSðŸŒ² We often use recursion to solve the problem that involves tree(data structure). A binary tree has three parts, left subtree, root, and right subtree. This logic applies to every node in the tree including leaf nodes. If it has back track, it would be easier to just use recursion. However, if it is a tail trcursion, it can be converted into simple loops. Under this broad definition, however, every algorithm that uses recursion or loops could be regarded as a â€œdivide and conquer algorithmâ€[1]. Search in Binary Search Treeinput: A root of a tree, and a target value.output: If exist, return the node; otherwise, return null. In a binary search tree, every node must satisfy the property that values in the left subtree must not be greater than it, and the value in the right subtree must not smaller than it. So we can recursively call the function. If the node value is smaller than target, look to its right. Otherwise, look to the left. Every time the function being called, the searching range is reduced to half. For a tree that has n nodes. The time complexity is O(logn). The space complexity is O(height) as well. However, the worst case could be O(n) if the tree is linear. Recursion 123456789101112public TreeNode searchBST(TreeNode root, int target) &#123; if (root == null) return null; if (root.val &lt; target) &#123; return searchBST(root.right, target); &#125; if(root.val &gt; target) &#123; return searchBST(root.left, target); &#125; return root.val == target ? root : null;&#125; IterationTime comlexity is the same. However, the space is O(1) in iteration. 123456789101112public TreeNode searchBST(TreeNode root, int target) &#123; if (root == null) return null; while (root != null &amp;&amp; root.val != target) &#123; if (root.val &lt; target) &#123; root = root.right; &#125; else &#123; root = root.left; &#125; &#125; return root;&#125; å¦‚æžœæ‰€æœ‰çš„é—®é¢˜éƒ½è¿™ä¹ˆç®€å•, ä¸–ç•Œè¯¥å¤šä¹ˆç¾Žå¥½ âœ§à­§(à¹‘=Ì´Ì€âŒ„=Ì´Ìà¹‘)à«­âœ§ ê’° Insert in Binary Search Treeinput: A root and a target.output: Return the root after insertion (maintain its BST property). If the target exists in the tree, do nothing. There would be two steps: find the position for the node. Since itâ€™s a binary search tree with no duplicate values, we can possibility find the postion under a leaf node. connect the node to the tree. Time compexity would be O(logn), where n is the number of node in the tree.Space compexity is the call stack, which is O(height). Recursion 123456789101112public TreeNode insert(TreeNode root, int target) &#123; if (root == null) return new TreeNode(target); if (root.val &lt; target) &#123; root.right = insert(root.right, target); &#125; if (root.val &gt; target) &#123; root.left = insert(root.left, target); &#125; return root;&#125; IterationTime complexity is O(logn).Space complexity is O(1). 123456789101112131415161718192021222324public TreeNode insert(TreeNode root, int target) &#123; if (root == null) return new TreeNode(target); TreeNode cur = root; TreeNode insetNode = new TreeNode(target); while (cur != null &amp;&amp; cur.val != target) &#123; if (cur.val &gt; target) &#123; if (cur.left == null) &#123; cur.left = insertNode; break; &#125; else &#123; cur = cur.left; &#125; &#125; else &#123; if (cur.right == null) &#123; cur.right = insertNode; break; &#125; else &#123; cur = cur.right; &#125; &#125; &#125; return root;&#125; Detele in Binary Search Treeinput: A root and the target.outpit: Return the root after deleting the target node in the tree (must maintain its BST property). If target doesnâ€™t exist, simply return the root. There will be two steps: Find the node. Simply search in the tree. Adjust the structure after deletion. There will be 4 cases when deleting a node: The node is leaf node â€“&gt; simply delete The node only has left/right subtree â€“&gt; percolate up left/right subtreeâ€™s root. Since the subtree itself is a BST , itâ€™s a subtree of the target node and it has no siblings (no need to compare with left/right subtree), it will maintain the property after lifting up. The node has both left and right subtree â€“&gt; pick a side, taking the largest node that is smaller than the node (look the left) or the smallest node that is greater than the node (look the right). Since weâ€™re looking for the largest smaller one or the smallest larger one, there will be two situations that need to be considered. If the left subtree of the target doesnâ€™t have a right subtree or the right subtree of the target doesnâ€™t have a left subtree. Then the root of the subtree is the candidate. Due to the property of bst, all the left subtree is smaller than it and all the right subtree is greater than it for every node in the tree. If the left/right subtree of the target node has both left and right children, implement a helper function to find the left/right most node. For a tree with n nodes, time complexity for searching target takes O(logn), and adjustment can take O(height) for getting the left/right most node in the subtree. Therefore, the time complexity is O(2 * height), then is O(height). Space complexity is O(height) for stack frame if using recursion. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public TreeNode delete(TreeNode root, in target) &#123; if (root == null) return null; //Step1. find the node if (root.val &gt; target) &#123; root.left = delete(root.left, target); return root; &#125; else if (root.val &lt; target) &#123; root.right = delete(root.right, target); return root; &#125; //Step2. current root is target, adjustment //root != null &amp;&amp; root.val == target; //case11 &amp; 2 if (root.left == null) &#123; return root.right; &#125; else if (root.right == null) &#123; return root.left; &#125; //root.left != null &amp;&amp; root.right != null //case3.1 pick right if (root.right.left == null) &#123; root.right.left = root.left; return root.right; &#125; //case3.2 pick right, then find the smallest in the right subtree; TreeNode smallest = findSmallest(root.right); //reconnect the node, then return. smallest.left = root.left; smallest.right = root.right; return smallest;&#125;private TreeNode findSmallest(TreeNode node) &#123; TreeNode prev = node; node = node.left; while (node.left != null) &#123; prev = node; node = node.left; &#125; //node.left == null, current node is the left most. pre is current at the parent of node. pre.left = node.right; return node; &#125;&#125; [1]: â€œDivide and Conquer Algorithm.â€ Wikipedia, Wikimedia Foundation, 3 Apr. 2018, en.wikipedia.org/wiki/Divide_and_conquer_algorithm.]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure V Tree II]]></title>
    <url>%2F2018%2F04%2F04%2FData%20Structure%20V%20Tree%20ii%2F</url>
    <content type="text"><![CDATA[â”€=â‰¡Î£((( ã¤â€¢Ì€Ï‰â€¢Ì)ã¤ Traverse ðŸŒ² Pre-order Traverse Binary Tree (LeetCode 144. Binary Tree Preorder Traversal)input: The root of a tree.output: The list of elements of the tree in pre-order. The main concept of traversal is to visit each element once and only once. Therefore, the time comlexity should be O(n), where n is the number of node in the tree.Space complexity If using recursion, the space is stack frame, which is at most O(height). Iteration would require a extra data structure to simulate the call stack, and thus itâ€™s O(height) as well. Recutsion 123456789101112131415161718192021public class traversePre &#123; /** * @param root * @return the preorder traversal of it's nodes' values; */ public List&lt;Integer&gt; traversePre(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return result; result.add(root.val); helper(root.left, result); helper(root.right, result); return result; &#125;&#125; Iteration 1234567891011121314151617181920212223242526public class traversePre &#123; /** * @param root * @return the preorder traversal of it's nodes' values; */ public List&lt;Integer&gt; traversePre(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); stack.offerFirst(root); //simulate the stack, so right first while (!stack.isEmpty()) &#123; TreeNode cur = stack.pollFirst(); result.add(cur.val); if (cur.right != null) stack.offerFirst(cur.right); if (cur.left != null) stack.offerFirst(cur.left); &#125; return result; &#125;&#125; In-order Traverse Binary Treeinput: The root of a tree.output: The list of elements of the tree in in-order. Same logic as pre-order. Therefore, time complexity is O(n), and space comlexity is O(height) for both recursion and iteration.Recursion 123456789101112131415161718192021public class TraverseIn &#123; /** * @param root of a binary tree * @return the inorder traversal of its nodes' values. */ public List&lt;Integer&gt; traverseIn(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return result; helper(root.left, result); result.add(root.val); helper(root.right, result); return result; &#125;&#125; IterationUsing A stack to simulate call stack. The process is push nodes along the left path. If reach the leaf node, pop the peek of the stack, which is the previous parent node of the leaf. If the peek node has a right child, push nodes along the left path of the child node as did before. Because of simulating the call stack, the space comlexity remains the same. T = O(n), S = O(height);123456789101112131415161718192021222324252627282930313233public class TraverseIn &#123; /** * @param root of a binary tree * @return the inorder traversal of its nodes' values. */ public List&lt;Integer&gt; traverseIn(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); pushLeft(root, stack); while (!stack.isEmpty()) &#123; TreeNode cur = stack.pollFirst(); result.add(cur.val); cur = cur.right; pushLeft(cur, stack); &#125; return result; &#125; private void pushLeft(TreeNode root, Deque&lt;TreeNode&gt; stack) &#123; while (root != null) &#123; stack.offerFirst(root); root = root.left; &#125; &#125;&#125; Post-order Traverse Binary Treeinput: The root of a tree.output: The list of elements of the tree in post-order. Same logic as pre-order. Therefore, time complexity is O(n), and space comlexity is O(height) for both recursion and iteration. Recursion 12345678910111213141516171819202122public class TraversePost &#123; /** * @param root of a binary tree * @return the postOrder traversal of its nodes' values. */ public List&lt;Integer&gt; traversePost(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return result; helper(root.left, result); helper(root.right,result); result.add(root.val); return result; &#125;&#125; IterationOnly pop the stack if right child is visited or it is the leaf node. There are two stages in the traversal, Tacking downward if current node is the root, push to the stack. if current node has child, push to the stack. if current node is the leaf node, update the result, pop from the stack. Backtracking if previous visited node is the left child, look at its right. if right child is not empty, push to the stack. if right child is empty, add current node into the result, and pop it from the stack. if previous visited node is the right child, this subtree is finished, pop the stack. There is a logic overlap. Whether the right is visited or the node doesnâ€™t have a right subtree, current node can be popped. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TraversePost &#123; /** * @param root of a binary tree * @return the postOrder traversal of its nodes' values. */ public List&lt;Integer&gt; traversePost(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); stack.offer(root); TreeNode prev = null; TreeNode cur = root; while (!stack.isEmpty()) &#123; cur = stack.peekFirst(); //cur is root, cur is leafnode if (prev == null || cur == prev.left || cur == prev.right) &#123; if (cur.left != null) &#123; stack.offerFirst(cur.left); &#125; else if (cur.right != null) &#123; stack.offerFirst(cur.right); //the peek of the stack (last added) is leaf &#125; else &#123; result.add(cur.val); stack.pollFirst(); &#125; //left child is visited &#125; else if (prev == cur.left) &#123; //if it has right child if (cur.right != null) &#123; stack.offerFirst(cur.right); &#125; /*else &#123; result.add(cur.val); stack.pollFirst(); &#125;*/ //if right child is visited. &#125; else &#123; result.add(cur.val); stack.pollFirst(); &#125; prev = cur; &#125; return result; &#125;&#125; Level Order Traverse Binary Treeinput: The root of a tree.output: The list of elements of the tree in level-order. The concept of traversal is as same as pre-order. However, the extra data structure being used here is a queue, which is FIFO, beacuse it goes from top to bottom and left to right.The time comlexity is O(n) as other traversal orders, but the space would be the level that has the most nodes in the tree. Then the worst case would be the leaf level in a perfect tree (every node has 2 children), so itâ€™s O(2/n - 1) â€“&gt; O(n). 123456789101112131415161718192021public class LevelOrder &#123; /** * @param root * @return */ public List&lt;Integer&gt; traverseLevel(TreeNode root) &#123; if (root == null) return new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); while (!q.isEmpty()) &#123; TreeNode cur = q.poll(); result.add(cur.val); if (cur.left != null) q.offer(cur.left); if (cur.right != null) q.offer(cur.right); &#125; return result; &#125;&#125; Identical Tree (LeetCode 100 Same Tree)input: roots of two binary trees.output: return whether they are structually identical and the nodes have the same number. Picking a traversal order and compare nodes value while traversing. Time complexity is O(n) where n is the number of nodes. Space complexity is O(height) if using preorder, inorder or postorder. O(n) is using level order.123456789101112131415161718192021public class SameTree &#123; /** * @param p root of a binary tree; * @param q root of a binary tree * @return whether they are the same */ public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) &#123; return true; &#125; if (p == null || q == null) &#123; return false; &#125; if (p.val != q.val) &#123; return false; &#125; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125;&#125; Minimum Depth of Binary Tree (LeetCode 111)input: root of a bianry tree.output: the min depth of the tree. There are 2 cases: If the root doesnâ€™t have left subtree or left subtree, min depth is the depth. If the root has a left subtree and a right subtree, return the min depht of its subtree plus 1 for current level of the root. Since only visit each node once, time complexity is O(n). Space complexity is O(height). 1234567891011121314151617181920public class MinDepth &#123; /** * @param root * @return min depth */ public int minDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; if (root.left == null) &#123; return minDepth(root.right) + 1; &#125; if (root.right == null) &#123; return minDepth(root.left) + 1; &#125; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; &#125;&#125; Balanced Binary Tree (LeetCode 110)input: root of a binary tree;output: whether the tree is balanced. A binary tree in which the depth of the two subtrees of every node never differ by more than 1.1 Since it deals with the height of a tree, the main concept is to get the height of each subtree. The difference of height needs to be checked for every node in the tree according to the definition of a balanced binary tree. Therefore, it is easier to use recursion. They way to get the height of a tree is returning the maximum of left and right subtree and plus 1 for the level of root.At each level, root checks whether itâ€™s left and right subtree are balanced, if so, return the height. Otherwise, return a special value shown that there exists an unbalanced subtree. Since it takes the same time as getting the height of a tree, the time comlexity is O(n). The space complexity is O(height). 123456789101112131415161718192021222324public class isBalanced &#123; /** * @param root of a binary tree * @return if it is height-balanced */ public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return getHeight(root) != -1; &#125; private int getHeight(TreeNode root) &#123; if (root == null) return 0; int left = getHeight(root.left); int right = getHeight(root.right); if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) &#123; return -1; &#125; return Math.max(left, right) + 1; &#125;&#125; Flatten Binary Tree to LinkedListinput: root of a binary tree;output: void 1 / \ 2 5 / \ \3 4 6 =&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 Assume all nodes are already connected, at each level, the root needs to do two things. Connect previous nodes to itâ€™s right, and disconnect itâ€™s left child. For example, if focusing on the subtree 2 -&gt; 3 -&gt; 4, at the point the root is 2, node 3 and node 4 are already connected, because itâ€™s postorder traversal. Using a class field to save previous connected node.Using postorder traversal, the most right leaf node is the tail node of the linked list. Time comlexity is O(n) where n is the number of nodes in the tree. Space complexity is O(height) due to the use of call stack. 123456789101112131415public class FlattenTreeToList &#123; /** * @param root of a binary tree */ private TreeNode prev = null; public void flatten(TreeNode root) &#123; if (root == null) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; &#125;&#125; Lowest Common Ancestor (LCA) Iinput: root of a binary tree, and two target nodes. Target Nodes are guaranteed to be in the tree.output: find the lowest comment ancestor of two target nodes. The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself)2. Using post order traverse, return target exist in the subtree otherwise return nothing. Time complexity is O(n) where n is the number of nodes in the tree. Space complexity is O(height) for call stack. The process is shown in the picture. 12345678910111213141516171819202122public class LCAI &#123; /** * @param root * @param a * @param b * @return */ public TreeNode lca(TreeNode root, TreeNode a, TreeNode b) &#123; if (root == null || root == a || root == b) &#123; return root; &#125; TreeNode left = lca(root.left, a, b); TreeNode right = lca(root.right, a, b); if (left == null) return right; if (right == null) return left; //left != null &amp;&amp; right != null return root; &#125;&#125; Count Univalue Subtrees (LeetCode 250)input: root node of a binary tree.output: return number of subtrees that have same value. Beacuse of looking for subtree, it is better to use post order traverse. Here uses return value to determine whether the root can form a valid subtree. If so, the root adds to the result. Otherwise, result number remains the same. There are two things to do at each level. comparing the nodes of left and right subtree to the root. updating the number of univalue subtree.IFF both left and right subtree are valid subtree and the valud of nodes of both left and right subtrees (if exist) and the value of root are the same, number of subtree can be updated. Since whether root can be counted as a univalue subtree is rely one the value of its subtree, there should be passing a boolean value. At the meantime, count needs to be updated (or not). ç§ã¯ã“ã“ã§ã‚¨ãƒ©ãƒ¼ã‚’ã—ãŸã€‚ã‚µãƒ–ãƒ„ãƒªãƒ¼ã®æ•°ã‚’é–“é•ã£ã¦ç›´æŽ¥æ¸¡ã™. ã§ã‚‚ã€ã“ã®æ–¹æ³•ã¯ã€ã“ã‚“ãªã®çŠ¶æ³ã«å¯¾å‡¦ã™ã‚‹æ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚Since itâ€™s using post order traverse, every node will be visited once. The time complexity is O(n). Space compelxity is O(height) for call stack. 1234567891011121314151617181920212223242526272829303132333435public class UniValueSubtree &#123; /** * @param root * @return */ public int countUnivalSubtrees(TreeNode root) &#123; if (root == null) return 0; int[] count = &#123;0&#125;; helper(root, count); return count[0]; &#125; private boolean helper(TreeNode root, int[] count) &#123; if (root == null) return true; boolean left = helper(root.left, count); boolean right = helper(root.right, count); //if (root.left == null &amp;&amp; root.right == null) count[0]++; //root == null returns true guarantees leaf node count++; if (left &amp;&amp; right) &#123; if (root.left != null &amp;&amp; root.left.val != root.val) &#123; return false; &#125; if (root.right != null &amp;&amp; root.right.val != root.val) &#123; return false; &#125; count[0]++; return true; &#125; ///////had made a mistake here, keep in mind.... return false; &#125;&#125; Check Full Binary Treeinput: root of a binary tree.output: return whether its a full tree. A binary tree in which all nodes have either zero or two child nodes. Using post order traversal, if any of the tree node has single child, return false. Time complexity is O(n). Space complexity is O(height) for call stack.1234567891011121314151617public class CheckFullTree &#123; /** * @param root: the given tree * @return: Whether it is a full tree */ public boolean isFullTree(TreeNode root) &#123; if (root == null) return true; if (root.left == null &amp;&amp; root.right == null) &#123; return true; &#125; if (root.left == null || root.right == null) &#123; return false; &#125; return isFullTree(root.left) &amp;&amp; isFullTree(root.right); &#125;&#125; Maximum Path Sum Iinput: a root of a binary tree.output: maximum value from one leaf node to another leaf node. Using a reference to keep global max. While traversing, if a root has both left and right subtree, it is a candidate to update global max value. Otherwise, return the maximum value of left and right plus the rootâ€™s value. The time complexity is O(n) becuase only visit every node once. The space complexity is O(height) due to the call stack. 123456789101112131415161718192021222324252627public class MaxPathSumI &#123; /** * @param root * @return */ public int maxPathSum(TreeNode root) &#123; int[] max = &#123;Integer.MIN_VALUE&#125;; helper(root, max); return max[0]; &#125; private int helper(TreeNode root, int[] max) &#123; if (root == null) &#123; return 0; &#125; int left = helper(root.left, max); int right = helper(root.right, max); if (root.left != null &amp;&amp; root.right != null) &#123; max[0] = Math.max(max[0], left + right + root.val); return Math.max(left, right) + root.val; &#125; //if not return, left == null || right == null return root.left == null ? right + root.val : left + root.val; &#125;&#125; Maximum Path Sum IIinput: a root of a binary tree.output: maximum value from any node to any node (contains at least one node). The only difference between this problem and previous one is the condition of updating global max. If the sum returned from subtree is positive, keep it and compare. Otherwise, set it to 0. The time complexity is O(n) beacuse it only visits every node once. The space complexity is O(height) due to the call stack. public class MaxPathSumII { /** * @param root * @return */ public int maxPathSum(TreeNode root) { int[] max = {Integer.MIN_VALUE}; helper(root, max); return max[0]; } private int helper(TreeNode root, int[] max) { if (root == null) return 0; int left = helper(root.left, max); int right =helper(root.right, max); left = left &lt; 0 ? 0 : left; right = right &lt; 0 ? 0 : right; max[0] = Math.max(max[0], left + right + root.val); return Math.max(left, right) + root.val; } } ### 1.https://leetcode.com/problems/balanced-binary-tree/description/ â†©2.https://en.wikipedia.org/wiki/Lowest_common_ancestor â†©]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure V Tree I]]></title>
    <url>%2F2018%2F04%2F03%2FData%20Structure%20V%20Tree%2F</url>
    <content type="text"><![CDATA[A directed acyclic graph (DAG!) is a directed graph that contains no cycles. A rooted tree is a special kind of DAG and a DAG is a special kind of directed graph. For example, a DAG may be used to represent common subexpressions in an optimising compiler.[1] æ ‘çš„æ€§è´¨å¯¹äºŽçº¿æ€§æ•°æ®ç»“æž„æ¥è¯´, å…ƒç´ ä¸Žå…ƒç´ ä¹‹é—´çš„å…³ç³»æ˜¯ä¸€å¯¹ä¸€çš„. ä¾‹å¦‚, åœ¨ Linked list ä¸­, æ¯ä¸€ä¸ªå…ƒç´ åªæœ‰ä¸€ä¸ª preceding å’Œä¸€ä¸ª following element. è€Œå¯¹äºŽä¸€å¯¹å¤šçš„æƒ…å†µ, å°±éœ€è¦å¦å¤–ä¸€ç§æ•°æ®ç»“æž„æ ‘(tree)/å›¾(graph)æ¥å¤„ç†äº†. æ ‘æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å›¾(DAG). å¯¹äºŽä¸€ä¸ªéžç©ºçš„æ ‘æ¥è¯´, å®ƒæ˜¯ä¸€ä¸ªæ‹¥æœ‰ n ä¸ªèŠ‚ç‚¹(n &gt;= 0) çš„æœ‰é™é›†åˆ. è¿™ä¸ªé›†åˆæœ‰ä¸”åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹(root), å…¶ä»–èŠ‚ç‚¹å¯ä»¥è¢«çœ‹åšè‹¥å¹²ä¸ªä¸ç›¸äº¤çš„å­é›†(n - 1). è€Œè¿™ n - 1ä¸ªå­é›†è¢«è§†ä¸º root çš„å­æ ‘(subtree). é€šè¿‡ root å¯ä»¥è®¿é—®åˆ°å®ƒæ‰€æœ‰çš„å­æ ‘[2]. depth: ä»ŽèŠ‚ç‚¹åˆ° root çš„é«˜åº¦.height: ä»Ž root åˆ°ç¦»å®ƒæœ€è¿œçš„èŠ‚ç‚¹çš„è·ç¦».degree: èŠ‚ç‚¹æ‹¥æœ‰çš„å­æ ‘çš„æœ€å¤§æ•°é‡. å¯¹äºŽä¸€ä¸ª tree ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹æ¥è¯´, å®ƒçš„ parent èŠ‚ç‚¹æ˜¯ç¡®å®šçš„, ä½†æ˜¯ child èŠ‚ç‚¹å¯ä»¥æœ‰å¤šä¸ª. å¯¹äºŽå¤šä¸ªå­èŠ‚ç‚¹çš„è¡¨ç¤ºåˆ™å¯ä»¥ä½¿ç”¨ List è¿™ç§å½¢å¼æ¥è¡¨ç¤º. å¯¹äºŽæ¯ä¸€ä¸ªèŠ‚ç‚¹æ¥è¯´, å®ƒæœ‰å¤šå°‘ä¸ªå­æ ‘, å°±è¦æœ‰å¤šå°‘ä¸ª reference æŒ‡å‘è¿™äº›å­æ ‘. é‚£ä¹ˆåŒæ ·çš„, éåŽ†æ¯ä¸€ä¸ªå­æ ‘çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯å­æ ‘èŠ‚ç‚¹çš„ä¸ªæ•°. æ‰€ä»¥å¯¹äºŽä¸€ä¸ªæ²¡æœ‰ parent reference çš„tree, å› ä¸ºåªèƒ½å¤Ÿé€šè¿‡ root æ¥éåŽ†/æœç´¢å…ƒç´ , æ—¶é—´å¤æ‚åº¦ä¸º O(n). å¦‚æžœæœ‰å¿…è¦çš„æƒ…å†µä¸‹, å¯ä»¥å¢žåŠ ä¸€ä¸ª parent çš„åŸŸ. åœ¨é‡åˆ°å¤æ‚çš„æ ‘çŠ¶ç»“æž„çš„æ—¶å€™, å¯ä»¥ä½¿ç”¨ child refernce å’Œsibling reference æ¥æŒ‡å‘å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å’Œå…„å¼ŸèŠ‚ç‚¹. è¿™æ ·å°±å¯ä»¥è½¬åŒ–æˆä¸€ä¸ªç®€å•çš„äºŒå‰æ ‘çš„ç»“æž„äº†. äºŒå‰æ ‘ä¸‹é¢æ¥è¯´ä¸‹ç‰¹æ®Šçš„æ ‘, äºŒå‰æ ‘(binary tree). äºŒå‰æ ‘å…·æœ‰äº”ç§åŸºæœ¬å½¢æ€, ç©ºæ ‘, åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹, æ ¹èŠ‚ç‚¹åªæœ‰å·¦å­æ ‘, æ ¹èŠ‚ç‚¹åªæœ‰å³å­æ ‘, æ ¹èŠ‚ç‚¹æ‹¥æœ‰å·¦å³å­æ ‘. è¿™ä¸ªçŠ¶æ€é€‚ç”¨äºŽæ¯ä¸€ä¸ªèŠ‚ç‚¹. æ‰€ä»¥å¯¹äºŽä¸€ä¸ªæœ‰3ä¸ªèŠ‚ç‚¹çš„æ ‘æ¥è¯´, å®ƒåº”è¯¥å…·æœ‰å¦‚ä¸‹å‡ ç§å½¢æ€, æœ‰ä¸€äº›å½¢æ€å…·æœ‰ç‰¹æ®Šçš„æ€§è´¨, è¿™äº›æ€§è´¨å¯ä»¥å¸®åŠ©æˆ‘ä»¬é«˜æ•ˆçš„å¤„ç†ä¸€äº›æ•°æ®. ä¾‹å¦‚, æ»¡äºŒå‰æ ‘(full binary tree): æ¯ä¸€ä¸ªèŠ‚ç‚¹åªæœ‰ä¸¤ä¸ªçŠ¶æ€, æ²¡æœ‰å­æ ‘, æˆ–è€…æœ‰ä¸¤ä¸ªå­æ ‘. å®Œç¾ŽäºŒå‰æ ‘(perfect binary tree): é™¤å¶å­èŠ‚ç‚¹å¤–çš„ node éƒ½æ‹¥æœ‰2ä¸ªå­æ ‘, å¹¶ä¸”æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹éƒ½åœ¨åŒä¸€å±‚. ä¸Šå›¾ä¸­çš„ç¬¬ä¸€ä¸ª. å®Œå…¨äºŒå‰æ ‘(complete binary tree): ä»»æ„èŠ‚ç‚¹å­æ ‘ä¹‹é—´é«˜åº¦å·®ä¸è¶…è¿‡1, ä¹Ÿå°±æ˜¯è¯´å¶å­èŠ‚ç‚¹åªèƒ½å‡ºçŽ°åœ¨æœ€ä¸‹é¢ä¸¤å±‚, å¦‚æžœå¶å­èŠ‚ç‚¹ä¸åœ¨åŒä¸€å±‚, é‚£ä¹ˆæœ€ä¸‹ä¸€å±‚çš„å¶å­èŠ‚ç‚¹ä¸€å®šåœ¨å·¦è¾¹è¿žç»­ä½ç½®. åŒæ ·çš„, å¦‚æžœæ˜¯å€’æ•°ç¬¬äºŒå±‚çš„å¶å­èŠ‚ç‚¹, é‚£ä¹ˆä¸€å®šåœ¨æœ€å³è¾¹è¿žç»­ä½ç½®(å…¶å®žè®°ä½ bubble åœ¨å·¦å°±å¤Ÿäº†). å¦‚æžœä¸€ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­æ ‘, é‚£ä¹ˆè¿™ä¸ªå­æ ‘ä¸€å®šåœ¨å·¦è¾¹. åŒæ ·èŠ‚ç‚¹æ•°çš„äºŒå‰æ ‘, å®Œå…¨äºŒå‰æ ‘çš„æ·±åº¦æœ€å°. å¯¹äºŽä¸€ä¸ªæ‹¥æœ‰ n ä¸ªèŠ‚ç‚¹çš„å®Œå…¨äºŒå‰æ ‘æ¥è¯´, å®ƒçš„æ·±åº¦æ˜¯ logn + 1. è‹¥æŒ‰ç…§å±‚åºä»Ž1 ~ næŽ’åˆ—, å¯¹äºŽæ¯ä¸€ä¸ªå…ƒç´  i(1 &lt;= i &lt;= n), å¦‚æžœ i == 1, é‚£ä¹ˆ i æ˜¯ root, å¦‚æžœ i &gt; 1, å®ƒçš„ parent node æ˜¯ i / 2, å¦‚æžœ 2i &gt; n, åˆ™ i æ²¡æœ‰å·¦å­æ ‘( i ä¸ºå¶å­èŠ‚ç‚¹). å¦‚æžœ 2i == n, åˆ™ 2i æ˜¯ i çš„å·¦å­æ ‘. å¦‚æžœ2i + 1 &gt; n, åˆ™ i æ²¡æœ‰å³å­æ ‘. å¦‚æžœ2i + 1 == n, é‚£ä¹ˆ2i æ˜¯ i çš„å³å­æ ‘. å¹³è¡¡äºŒå‰æ ‘(balanced binary tree): ä»»æ„èŠ‚ç‚¹å­æ ‘ä¹‹é—´é«˜åº¦å·®ä¸è¶…è¿‡1. äºŒå‰æœç´¢æ ‘(binary search tree): å¯¹äºŽä»»æ„èŠ‚ç‚¹æ¥è¯´, å®ƒæ‰€æœ‰å·¦å­æ ‘ä¸èƒ½å¤§äºŽå®ƒ, æ‰€æœ‰å³å­æ ‘ä¸èƒ½å°äºŽå®ƒ. ä¸­åºéåŽ†ç»“æžœä¸€å®šæ˜¯å‡åº. perfect treeä¸€å®šæ˜¯å®Œå…¨äºŒå‰æ ‘, å®Œå…¨äºŒå‰æ ‘ä¸€å®šæ˜¯å¹³è¡¡äºŒå‰æ ‘.è¿™é‡Œ full tree å’Œ perfect tree çš„å®šä¹‰è¿˜æ˜¯æœ‰ä¸€äº›äº‰è®®â€¦. äºŒå‰æ ‘çš„éåŽ†äºŒå‰æ ‘çš„éåŽ†( traversing binary tree)æ˜¯æŒ‡ä»Ž root å‡ºå‘, æŒ‰ç…§æŸç§é¡ºåºè®¿é—®æ‰€æœ‰èŠ‚ç‚¹. æ¯ä¸ªèŠ‚ç‚¹åªè¢«è®¿é—®ä¸€æ¬¡.å¯¹äºŽä¸€ä¸ªäºŒå‰æ ‘æ¥è¯´, éåŽ†çš„é¡ºåºå¯ä»¥åˆ†ä¸ºæ·±åº¦ä¼˜å…ˆå’Œå®½åº¦ä¼˜å…ˆ. æ ¹æ®æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„ä½ç½®çš„ä¸åŒ, æ·±åº¦ä¼˜å…ˆåˆå¯ä»¥è¢«åˆ†ä¸ºå‰åº, ä¸­åºå’ŒåŽåºéåŽ†. pre-order traverse: å¯¹äºŽæ¯ä¸€ä¸ªèŠ‚ç‚¹æ¥è¯´, å…ˆè®¿é—®å®ƒè‡ªå·±, å†è®¿é—®å·¦å­æ ‘, ç„¶åŽè®¿é—®å³å­æ ‘. ä¸Šå›¾ç»“æžœåº”è¯¥æ˜¯, 18 --&gt; 4 --&gt; 2 --&gt; 1 --&gt; 3 --&gt; 6 --&gt; 5 --&gt; 7 --&gt; 12 --&gt; 10 --&gt; 9 --&gt; 11 --&gt; 14 --&gt; 13 --&gt; 15 in-order traverse: å¯¹äºŽæ¯ä¸€ä¸ªèŠ‚ç‚¹æ¥è¯´, å…ˆè®¿é—®å·¦å­æ ‘, åœ¨è®¿é—®å®ƒè‡ªå·±, ç„¶åŽè®¿é—®å³å­æ ‘( root åœ¨ä¸­é—´). ä¸Šå›¾ç»“æžœåº”è¯¥æ˜¯, 11 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6 --&gt; 7 --&gt; 8 --&gt; 9 --&gt; 10 --&gt; 11 --&gt; 12 --&gt; 13 --&gt; 14 --&gt; 15 post-order traverse: åŒç†, å…ˆå·¦å­æ ‘, ç„¶åŽå³å­æ ‘, æœ€åŽè®¿é—®å®ƒè‡ªå·±. ä¸Šå›¾è®¿é—®ç»“æžœ, 115 --&gt; 13 --&gt; 14 --&gt; 11 --&gt; 9 --&gt; 10 --&gt; 12 --&gt; 7 --&gt; 5 --&gt; 6 --&gt; 3 --&gt; 1 --&gt; 2 --&gt; 4 --&gt; 8 level oder traverse: ä»Žä¸Šåˆ°ä¸‹, ä»Žå·¦åˆ°å³åˆ†å±‚è®¿é—®, é€šå¸¸ä¼šç”¨ä¸€ä¸ª queue æ¥å‚¨å­˜æ¯ä¸€å±‚çš„ TreeNode, 18 --&gt; 4 --&gt; 12 --&gt; 2 --&gt; 6 --&gt; 10 --&gt; 14 --&gt; 1 --&gt; 3 --&gt; 5 --&gt; 7 --&gt; 9 --&gt; 11 --&gt; 13 --&gt; 15 å·²çŸ¥å‰åºéåŽ†/åŽåºéåŽ†å’Œä¸­åºéåŽ†å¯ä»¥ç¡®å®šå”¯ä¸€ä¸€ä¸ªäºŒå‰æ ‘, è€ŒçŸ¥é“å‰åºéåŽ†å’ŒåŽç»­éåŽ†åˆ™æ— æ³•è¿˜åŽŸä¸€ä¸ªäºŒå‰æ ‘çš„. è¿™æ˜¯å› ä¸ºé€šè¿‡å‰åº/åŽç»­éåŽ†å¯ä»¥è½»è€Œæ˜“ä¸¾çš„ç¡®å®š root, è€Œä¸­åºéåŽ†åˆ™å¯ä»¥é€šè¿‡è¿™ä¸ª root æ¥ç¡®å®šå·¦å³å­æ ‘çš„èŒƒå›´. ä¸¾ä¾‹è¯´æ˜Žä¸Šé¢ç»“æžœä¸­å‰åºéåŽ†å’Œä¸­åºéåŽ†å¦‚ä½•è¿˜åŽŸä¸€ä¸ªäºŒå‰æ ‘. å·²ç»pre-order ä¸­, 8æ˜¯å”¯ä¸€ç¡®å®šçš„ root, é‚£ä¹ˆin-order ä¸­, 1 ~ 7åˆ™ä¸€å®šæ˜¯å·¦å­æ ‘, 9 ~ 12 ä¸€å®šæ˜¯å³å­æ ‘. å¦‚ä¸‹,ç»§ç»­é€šè¿‡pre-oder çš„é¡ºåºèŽ·å–å·¦å­æ ‘root,ç›´åˆ°æœ€åŽå·¦å³å­æ ‘å…ƒç´ ä¸º1, é‚£ä¹ˆç¡®å®šä¸ºå¶å­èŠ‚ç‚¹. æœ€åŽå†é€šè¿‡åŒæ ·çš„é€»è¾‘è¿˜åŽŸå³å­æ ‘. æŠŠäºŒå‰æ ‘ä»¥æŸç§é¡ºåºçº¿ç´¢åŒ–(åŒé“¾è¡¨æˆ–è€… arraylist)çš„è¿‡ç¨‹å«åšåºåˆ—åŒ–, åä¹‹åˆ™æ˜¯ååºåˆ—åŒ–. [1]: â€œDirected Acyclic Graphs.â€ Directed Acyclic Graph (DAG) Algorithms, www.allisons.org/ll/AlgDS/Graph/DAG/.[2]: ã€Šå¤§è¯æ•°æ®ç»“æž„ã€‹ ç¨‹æ°. www.bing.com/cr?IG=31B9721229184349AAEC19BE676BAC6F&amp;CID=362C81AF801A620D0EAF8A7881B563E4&amp;rd=1&amp;h=OJ2Sq1D4wfXY6mddIv_zw1DEo8UFjkz32ZCngLj1biE&amp;v=1&amp;r=https://www.amazon.cn/dp/B0053F0HNW&amp;p=DevEx.LB.1,5871.1.]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linear Data Structure iii Stack]]></title>
    <url>%2F2018%2F04%2F03%2FLinear%20Data%20Structure%20iii%2F</url>
    <content type="text"><![CDATA[çº¿æ€§æ•°æ®ç»“æž„(ä¸‰) æ ˆStack æ˜¯ä¸€ç§åŽè¿›å…ˆå‡ºçš„æ•°æ®ç»“æž„(FILO), åŸºæœ¬çš„æ“ä½œæœ‰ push(), pop(), peek(), size() å’Œ isEmpty(). å› ä¸ºå®ƒåªèƒ½ä»Žä¸€è¾¹è¿›å‡º, æ‰€ä»¥æ˜¯å€’åºçš„æ“ä½œ.æ‰€ä»¥å¯èƒ½æƒ³åˆ°çš„åº”ç”¨åœºæ™¯åº”è¯¥æ˜¯å„ç§å¯¹äºŽé¡ºåºçš„æ“ä½œ. ä»¥åŠç›¸é‚»ä¸¤ä¸ªå…ƒç´ è¿›è¡Œå¯¹æ¯”. è™½ç„¶å®ƒçš„æ“ä½œå¾ˆç®€å•, ä½†æ˜¯æ ¹æ®è¿›æ ˆå’Œå‡ºæ ˆçš„é¡ºåºä¸åŒ, å¯ä»¥å¾—å‡ºä¸åŒçš„ç»“æžœ. 12345678910æ ˆå†…å…ƒç´ : 1, 2, 3å‡ºæ ˆçš„é¡ºåºå¯èƒ½æœ‰: 3, 2, 1; 1, 2, 3; 2, 3, 1; 2, 1, 3; 1, 3, 2;å”¯ä¸€ä¸å¯èƒ½æ˜¯æƒ…å†µæ˜¯312, å› ä¸ºå¦‚æžœ3 å·²ç»è¿›æ ˆäº†, é‚£ä¹ˆå°±æ„å‘³ç€ 1 å’Œ 2 å·²ç»è¿›(è¿‡)æ ˆäº†. è€Œ1 æ¯” 2 å…ˆè¿›æ ˆ, ä¸å¯èƒ½æ¯”2å…ˆå‡ºæ ˆ. A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example: Deque stack = new ArrayDeque(); Java ä¸­ stack çš„å®žçŽ°é€šå¸¸ä¼šä½¿ç”¨ Deque è¿™ä¸ª interface, è€Œä¸å†ä½¿ç”¨ Stack è¿™ä¸ªç±»äº†. å…·ä½“åŽŸå› : å¯¹äºŽæœ€æ–°çš„ Java framework æ¥è¯´, Stack çš„çº¿ç¨‹å®‰å…¨æ˜¾å¾—å¤ªå†—ä½™. é€šè¿‡ LinkedList å’Œ ArrayList å®žçŽ°çš„ Deque å¯ä»¥å®žçŽ° Deque å’Œ Stack çš„å„ç§å¢žåˆ æ”¹æŸ¥åŠŸèƒ½. è¿™æ ·ä½¿å¾—æ•°æ®ç»“æž„çš„æ•´åˆæ›´åŠ ç»Ÿä¸€, ä½¿ç”¨ generic ç±»åž‹æ¥åˆ›å»ºå¯¹è±¡ä¹Ÿæ›´ç¬¦åˆ Java OOP çš„è®¾è®¡ç†å¿µ. æœ€åŽ LinkedList å’Œ ArrayList éƒ½ä¸æ˜¯ Synchronized, æ‰€ä»¥å¼€é”€æ›´å°. ä½¿ç”¨ Deque æŽ¥å£: operation FistElement Last Element return type exception null Exception null insert addFirst offerFirst addLast offerLast remove removeFirst pollFirst removeLast removeFirst examine getFirst peekFirst getLast peekLast ä»£ç å®žçŽ°: ä½¿ç”¨LinkedList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyStackLL&lt;E&gt; &#123; private static class ListNode&lt;E&gt; &#123; public E val; public ListNode next; public ListNode(E val) &#123; this.val = val; this.next = null; &#125; &#125; private ListNode head; private int size; public MyStackLL()&#123; head = null; &#125; public void push(E e)&#123; ListNode&lt;E&gt; node = new ListNode(e); node.next = head; head = node; size++; &#125; public E pop()&#123; if (head == null) &#123; return null; &#125; ListNode&lt;E&gt; node = head; head = head.next; node.next = null; size--; return node.val; &#125; public Object peek() &#123; if (head == null) &#123; return null; &#125; else &#123; return head.val; &#125; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; ä½¿ç”¨Array 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyStackAL&lt;E&gt; &#123; private Object[] array; private static final int CAP = 16; private static final int SCALE_FACTOR = 2; int top; int size; public MyStackAL() &#123; array = new Object[CAP]; top = -1; &#125; public void push(E e) &#123; if (top == array.length - 1) &#123; array = Arrays.copyOf(array, CAP * SCALE_FACTOR); &#125; array[++top] = e; size++; &#125; public Object pop() &#123; if (top &lt; 0) &#123; return null; &#125; Object res = array[top--]; size--; return res; &#125; public Object peek() &#123; return top &lt; 0 ? null : array[top]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; æ‰€æœ‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å‡ä¸º O(1), ä½¿ç”¨ array çš„æ‰©å®¹æ–¹æ³• amortize çš„æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ˜¯ O(1). because the initial capacity is n. At the time we need to extend the capacity of the stack, it takes O(n) to copy the elements, and push operation will take O(1) for the upcoming n elements. When we add up the time of copy and adding, the average time complexity for each of upcoming elements will be O(n) + O(n) / n = O(2). Thus the amortized time complexity is O(1).]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>review plan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure]]></title>
    <url>%2F2018%2F04%2F01%2FData-Structure%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>review plan</tag>
      </tags>
  </entry>
</search>
